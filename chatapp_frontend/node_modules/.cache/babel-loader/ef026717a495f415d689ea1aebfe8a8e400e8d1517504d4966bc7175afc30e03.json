{"ast":null,"code":"'use strict';\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) return target.slice(0, offset);\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n  return buf;\n}\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bufferUtil.mask(source, mask, output, offset, length);\n    };\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}","map":{"version":3,"names":["EMPTY_BUFFER","require","concat","list","totalLength","length","target","Buffer","allocUnsafe","offset","i","buf","set","slice","_mask","source","mask","output","_unmask","buffer","toArrayBuffer","byteLength","byteOffset","toBuffer","data","readOnly","isBuffer","ArrayBuffer","from","isView","module","exports","unmask","process","env","WS_NO_BUFFER_UTIL","bufferUtil","e"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/socket.io-adapter/node_modules/ws/lib/buffer-util.js"],"sourcesContent":["'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}