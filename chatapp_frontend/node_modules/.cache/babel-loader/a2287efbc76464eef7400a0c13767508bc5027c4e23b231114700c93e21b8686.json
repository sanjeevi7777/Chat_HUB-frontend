{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polling = void 0;\nconst transport_1 = require(\"../transport\");\nconst zlib_1 = require(\"zlib\");\nconst accepts = require(\"accepts\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n  gzip: zlib_1.createGzip,\n  deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  constructor(req) {\n    super(req);\n    this.closeTimeout = 30 * 1000;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n  get name() {\n    return \"polling\";\n  }\n  get supportsFraming() {\n    return false;\n  }\n  /**\n   * Overrides onRequest.\n   *\n   * @param req\n   *\n   * @api private\n   */\n  onRequest(req) {\n    const res = req.res;\n    // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n    req.res = null;\n    if (req.getMethod() === \"get\") {\n      this.onPollRequest(req, res);\n    } else if (req.getMethod() === \"post\") {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeStatus(\"500 Internal Server Error\");\n      res.end();\n    }\n  }\n  /**\n   * The client sends a request awaiting for us to send data.\n   *\n   * @api private\n   */\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\");\n      // assert: this.res, '.req and .res should be (un)set together'\n      this.onError(\"overlap from client\");\n      res.writeStatus(\"500 Internal Server Error\");\n      res.end();\n      return;\n    }\n    debug(\"setting request\");\n    this.req = req;\n    this.res = res;\n    const onClose = () => {\n      this.writable = false;\n      this.onError(\"poll connection closed prematurely\");\n    };\n    const cleanup = () => {\n      this.req = this.res = null;\n    };\n    req.cleanup = cleanup;\n    res.onAborted(onClose);\n    this.writable = true;\n    this.emit(\"drain\");\n    // if we're still writable but had a pending close, trigger an empty send\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n  }\n  /**\n   * The client sends a request with data.\n   *\n   * @api private\n   */\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeStatus(\"500 Internal Server Error\");\n      res.end();\n      return;\n    }\n    const expectedContentLength = Number(req.headers[\"content-length\"]);\n    if (!expectedContentLength) {\n      this.onError(\"content-length header required\");\n      res.writeStatus(\"411 Length Required\").end();\n      return;\n    }\n    if (expectedContentLength > this.maxHttpBufferSize) {\n      this.onError(\"payload too large\");\n      res.writeStatus(\"413 Payload Too Large\").end();\n      return;\n    }\n    const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n    if (isBinary && this.protocol === 4) {\n      return this.onError(\"invalid content\");\n    }\n    this.dataReq = req;\n    this.dataRes = res;\n    let buffer;\n    let offset = 0;\n    const headers = {\n      // text/html is required instead of text/plain to avoid an\n      // unwanted download dialog on certain user-agents (GH-43)\n      \"Content-Type\": \"text/html\"\n    };\n    this.headers(req, headers);\n    for (let key in headers) {\n      res.writeHeader(key, String(headers[key]));\n    }\n    const onEnd = buffer => {\n      this.onData(buffer.toString());\n      this.onDataRequestCleanup();\n      res.cork(() => {\n        res.end(\"ok\");\n      });\n    };\n    res.onAborted(() => {\n      this.onDataRequestCleanup();\n      this.onError(\"data request connection closed prematurely\");\n    });\n    res.onData((arrayBuffer, isLast) => {\n      const totalLength = offset + arrayBuffer.byteLength;\n      if (totalLength > expectedContentLength) {\n        this.onError(\"content-length mismatch\");\n        res.close(); // calls onAborted\n        return;\n      }\n      if (!buffer) {\n        if (isLast) {\n          onEnd(Buffer.from(arrayBuffer));\n          return;\n        }\n        buffer = Buffer.allocUnsafe(expectedContentLength);\n      }\n      Buffer.from(arrayBuffer).copy(buffer, offset);\n      if (isLast) {\n        if (totalLength != expectedContentLength) {\n          this.onError(\"content-length mismatch\");\n          res.writeStatus(\"400 Content-Length Mismatch\").end();\n          this.onDataRequestCleanup();\n          return;\n        }\n        onEnd(buffer);\n        return;\n      }\n      offset = totalLength;\n    });\n  }\n  /**\n   * Cleanup request.\n   *\n   * @api private\n   */\n  onDataRequestCleanup() {\n    this.dataReq = this.dataRes = null;\n  }\n  /**\n   * Processes the incoming data payload.\n   *\n   * @param {String} encoded payload\n   * @api private\n   */\n  onData(data) {\n    debug('received \"%s\"', data);\n    const callback = packet => {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        this.onClose();\n        return false;\n      }\n      this.onPacket(packet);\n    };\n    if (this.protocol === 3) {\n      this.parser.decodePayload(data, callback);\n    } else {\n      this.parser.decodePayload(data).forEach(callback);\n    }\n  }\n  /**\n   * Overrides onClose.\n   *\n   * @api private\n   */\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n    super.onClose();\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n  send(packets) {\n    this.writable = false;\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({\n        type: \"close\"\n      });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n    const doWrite = data => {\n      const compress = packets.some(packet => {\n        return packet.options && packet.options.compress;\n      });\n      this.write(data, {\n        compress\n      });\n    };\n    if (this.protocol === 3) {\n      this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n    } else {\n      this.parser.encodePayload(packets, doWrite);\n    }\n  }\n  /**\n   * Writes data as response to poll request.\n   *\n   * @param {String} data\n   * @param {Object} options\n   * @api private\n   */\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    this.doWrite(data, options, () => {\n      this.req.cleanup();\n    });\n  }\n  /**\n   * Performs the write.\n   *\n   * @api private\n   */\n  doWrite(data, options, callback) {\n    // explicit UTF-8 is required for pages not served under utf\n    const isString = typeof data === \"string\";\n    const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n    const headers = {\n      \"Content-Type\": contentType\n    };\n    const respond = data => {\n      this.headers(this.req, headers);\n      this.res.cork(() => {\n        Object.keys(headers).forEach(key => {\n          this.res.writeHeader(key, String(headers[key]));\n        });\n        this.res.end(data);\n      });\n      callback();\n    };\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n    const len = isString ? Buffer.byteLength(data) : data.length;\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n    this.compress(data, encoding, (err, data) => {\n      if (err) {\n        this.res.writeStatus(\"500 Internal Server Error\");\n        this.res.end();\n        callback(err);\n        return;\n      }\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n  }\n  /**\n   * Compresses data.\n   *\n   * @api private\n   */\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n    const buffers = [];\n    let nread = 0;\n    compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }).on(\"end\", function () {\n      callback(null, Buffer.concat(buffers, nread));\n    }).end(data);\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n  doClose(fn) {\n    debug(\"closing\");\n    let closeTimeoutTimer;\n    const onClose = () => {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      this.onClose();\n    };\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{\n        type: \"close\"\n      }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n  }\n  /**\n   * Returns headers for a response.\n   *\n   * @param req - request\n   * @param {Object} extra headers\n   * @api private\n   */\n  headers(req, headers) {\n    headers = headers || {};\n    // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n    const ua = req.headers[\"user-agent\"];\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n    headers[\"cache-control\"] = \"no-store\";\n    this.emit(\"headers\", headers, req);\n    return headers;\n  }\n}\nexports.Polling = Polling;","map":{"version":3,"names":["Object","defineProperty","exports","value","Polling","transport_1","require","zlib_1","accepts","debug_1","debug","default","compressionMethods","gzip","createGzip","deflate","createDeflate","Transport","constructor","req","closeTimeout","name","supportsFraming","onRequest","res","getMethod","onPollRequest","onDataRequest","writeStatus","end","onError","onClose","writable","cleanup","onAborted","emit","shouldClose","send","type","dataReq","expectedContentLength","Number","headers","maxHttpBufferSize","isBinary","protocol","dataRes","buffer","offset","key","writeHeader","String","onEnd","onData","toString","onDataRequestCleanup","cork","arrayBuffer","isLast","totalLength","byteLength","close","Buffer","from","allocUnsafe","copy","data","callback","packet","onPacket","parser","decodePayload","forEach","packets","push","doWrite","compress","some","options","write","encodePayload","supportsBinary","isString","contentType","respond","keys","httpCompression","len","length","threshold","encoding","encodings","err","buffers","nread","on","chunk","concat","doClose","fn","closeTimeoutTimer","clearTimeout","discarded","setTimeout","ua","indexOf"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/engine.io/build/transports-uws/polling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polling = void 0;\nconst transport_1 = require(\"../transport\");\nconst zlib_1 = require(\"zlib\");\nconst accepts = require(\"accepts\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate,\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     *\n     * @api public.\n     */\n    constructor(req) {\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     *\n     * @api public\n     */\n    get name() {\n        return \"polling\";\n    }\n    get supportsFraming() {\n        return false;\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param req\n     *\n     * @api private\n     */\n    onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (req.getMethod() === \"get\") {\n            this.onPollRequest(req, res);\n        }\n        else if (req.getMethod() === \"post\") {\n            this.onDataRequest(req, res);\n        }\n        else {\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @api private\n     */\n    onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = () => {\n            this.writable = false;\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = () => {\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        res.onAborted(onClose);\n        this.writable = true;\n        this.emit(\"drain\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([{ type: \"noop\" }]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @api private\n     */\n    onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        const expectedContentLength = Number(req.headers[\"content-length\"]);\n        if (!expectedContentLength) {\n            this.onError(\"content-length header required\");\n            res.writeStatus(\"411 Length Required\").end();\n            return;\n        }\n        if (expectedContentLength > this.maxHttpBufferSize) {\n            this.onError(\"payload too large\");\n            res.writeStatus(\"413 Payload Too Large\").end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let buffer;\n        let offset = 0;\n        const headers = {\n            // text/html is required instead of text/plain to avoid an\n            // unwanted download dialog on certain user-agents (GH-43)\n            \"Content-Type\": \"text/html\",\n        };\n        this.headers(req, headers);\n        for (let key in headers) {\n            res.writeHeader(key, String(headers[key]));\n        }\n        const onEnd = (buffer) => {\n            this.onData(buffer.toString());\n            this.onDataRequestCleanup();\n            res.cork(() => {\n                res.end(\"ok\");\n            });\n        };\n        res.onAborted(() => {\n            this.onDataRequestCleanup();\n            this.onError(\"data request connection closed prematurely\");\n        });\n        res.onData((arrayBuffer, isLast) => {\n            const totalLength = offset + arrayBuffer.byteLength;\n            if (totalLength > expectedContentLength) {\n                this.onError(\"content-length mismatch\");\n                res.close(); // calls onAborted\n                return;\n            }\n            if (!buffer) {\n                if (isLast) {\n                    onEnd(Buffer.from(arrayBuffer));\n                    return;\n                }\n                buffer = Buffer.allocUnsafe(expectedContentLength);\n            }\n            Buffer.from(arrayBuffer).copy(buffer, offset);\n            if (isLast) {\n                if (totalLength != expectedContentLength) {\n                    this.onError(\"content-length mismatch\");\n                    res.writeStatus(\"400 Content-Length Mismatch\").end();\n                    this.onDataRequestCleanup();\n                    return;\n                }\n                onEnd(buffer);\n                return;\n            }\n            offset = totalLength;\n        });\n    }\n    /**\n     * Cleanup request.\n     *\n     * @api private\n     */\n    onDataRequestCleanup() {\n        this.dataReq = this.dataRes = null;\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @api private\n     */\n    onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet) => {\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        }\n        else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @api private\n     */\n    onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([{ type: \"noop\" }]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({ type: \"close\" });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data) => {\n            const compress = packets.some((packet) => {\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, { compress });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        }\n        else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @api private\n     */\n    write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, () => {\n            this.req.cleanup();\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @api private\n     */\n    doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString\n            ? \"text/plain; charset=UTF-8\"\n            : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType,\n        };\n        const respond = (data) => {\n            this.headers(this.req, headers);\n            this.res.cork(() => {\n                Object.keys(headers).forEach((key) => {\n                    this.res.writeHeader(key, String(headers[key]));\n                });\n                this.res.end(data);\n            });\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data) => {\n            if (err) {\n                this.res.writeStatus(\"500 Internal Server Error\");\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @api private\n     */\n    compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression)\n            .on(\"error\", callback)\n            .on(\"data\", function (chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        })\n            .on(\"end\", function () {\n            callback(null, Buffer.concat(buffers, nread));\n        })\n            .end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        const onClose = () => {\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([{ type: \"close\" }]);\n            onClose();\n        }\n        else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        }\n        else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param req - request\n     * @param {Object} extra headers\n     * @api private\n     */\n    headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,MAAMC,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMG,OAAO,GAAGH,OAAO,CAAC,OAAO,CAAC;AAChC,MAAMI,KAAK,GAAG,CAAC,CAAC,EAAED,OAAO,CAACE,OAAO,EAAE,gBAAgB,CAAC;AACpD,MAAMC,kBAAkB,GAAG;EACvBC,IAAI,EAAEN,MAAM,CAACO,UAAU;EACvBC,OAAO,EAAER,MAAM,CAACS;AACpB,CAAC;AACD,MAAMZ,OAAO,SAASC,WAAW,CAACY,SAAS,CAAC;EACxC;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAACC,GAAG,EAAE;IACb,KAAK,CAACA,GAAG,CAAC;IACV,IAAI,CAACC,YAAY,GAAG,EAAE,GAAG,IAAI;EACjC;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,IAAIA,CAAA,EAAG;IACP,OAAO,SAAS;EACpB;EACA,IAAIC,eAAeA,CAAA,EAAG;IAClB,OAAO,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,SAASA,CAACJ,GAAG,EAAE;IACX,MAAMK,GAAG,GAAGL,GAAG,CAACK,GAAG;IACnB;IACAL,GAAG,CAACK,GAAG,GAAG,IAAI;IACd,IAAIL,GAAG,CAACM,SAAS,CAAC,CAAC,KAAK,KAAK,EAAE;MAC3B,IAAI,CAACC,aAAa,CAACP,GAAG,EAAEK,GAAG,CAAC;IAChC,CAAC,MACI,IAAIL,GAAG,CAACM,SAAS,CAAC,CAAC,KAAK,MAAM,EAAE;MACjC,IAAI,CAACE,aAAa,CAACR,GAAG,EAAEK,GAAG,CAAC;IAChC,CAAC,MACI;MACDA,GAAG,CAACI,WAAW,CAAC,2BAA2B,CAAC;MAC5CJ,GAAG,CAACK,GAAG,CAAC,CAAC;IACb;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIH,aAAaA,CAACP,GAAG,EAAEK,GAAG,EAAE;IACpB,IAAI,IAAI,CAACL,GAAG,EAAE;MACVT,KAAK,CAAC,iBAAiB,CAAC;MACxB;MACA,IAAI,CAACoB,OAAO,CAAC,qBAAqB,CAAC;MACnCN,GAAG,CAACI,WAAW,CAAC,2BAA2B,CAAC;MAC5CJ,GAAG,CAACK,GAAG,CAAC,CAAC;MACT;IACJ;IACAnB,KAAK,CAAC,iBAAiB,CAAC;IACxB,IAAI,CAACS,GAAG,GAAGA,GAAG;IACd,IAAI,CAACK,GAAG,GAAGA,GAAG;IACd,MAAMO,OAAO,GAAGA,CAAA,KAAM;MAClB,IAAI,CAACC,QAAQ,GAAG,KAAK;MACrB,IAAI,CAACF,OAAO,CAAC,oCAAoC,CAAC;IACtD,CAAC;IACD,MAAMG,OAAO,GAAGA,CAAA,KAAM;MAClB,IAAI,CAACd,GAAG,GAAG,IAAI,CAACK,GAAG,GAAG,IAAI;IAC9B,CAAC;IACDL,GAAG,CAACc,OAAO,GAAGA,OAAO;IACrBT,GAAG,CAACU,SAAS,CAACH,OAAO,CAAC;IACtB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACG,IAAI,CAAC,OAAO,CAAC;IAClB;IACA,IAAI,IAAI,CAACH,QAAQ,IAAI,IAAI,CAACI,WAAW,EAAE;MACnC1B,KAAK,CAAC,8CAA8C,CAAC;MACrD,IAAI,CAAC2B,IAAI,CAAC,CAAC;QAAEC,IAAI,EAAE;MAAO,CAAC,CAAC,CAAC;IACjC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIX,aAAaA,CAACR,GAAG,EAAEK,GAAG,EAAE;IACpB,IAAI,IAAI,CAACe,OAAO,EAAE;MACd;MACA,IAAI,CAACT,OAAO,CAAC,kCAAkC,CAAC;MAChDN,GAAG,CAACI,WAAW,CAAC,2BAA2B,CAAC;MAC5CJ,GAAG,CAACK,GAAG,CAAC,CAAC;MACT;IACJ;IACA,MAAMW,qBAAqB,GAAGC,MAAM,CAACtB,GAAG,CAACuB,OAAO,CAAC,gBAAgB,CAAC,CAAC;IACnE,IAAI,CAACF,qBAAqB,EAAE;MACxB,IAAI,CAACV,OAAO,CAAC,gCAAgC,CAAC;MAC9CN,GAAG,CAACI,WAAW,CAAC,qBAAqB,CAAC,CAACC,GAAG,CAAC,CAAC;MAC5C;IACJ;IACA,IAAIW,qBAAqB,GAAG,IAAI,CAACG,iBAAiB,EAAE;MAChD,IAAI,CAACb,OAAO,CAAC,mBAAmB,CAAC;MACjCN,GAAG,CAACI,WAAW,CAAC,uBAAuB,CAAC,CAACC,GAAG,CAAC,CAAC;MAC9C;IACJ;IACA,MAAMe,QAAQ,GAAG,0BAA0B,KAAKzB,GAAG,CAACuB,OAAO,CAAC,cAAc,CAAC;IAC3E,IAAIE,QAAQ,IAAI,IAAI,CAACC,QAAQ,KAAK,CAAC,EAAE;MACjC,OAAO,IAAI,CAACf,OAAO,CAAC,iBAAiB,CAAC;IAC1C;IACA,IAAI,CAACS,OAAO,GAAGpB,GAAG;IAClB,IAAI,CAAC2B,OAAO,GAAGtB,GAAG;IAClB,IAAIuB,MAAM;IACV,IAAIC,MAAM,GAAG,CAAC;IACd,MAAMN,OAAO,GAAG;MACZ;MACA;MACA,cAAc,EAAE;IACpB,CAAC;IACD,IAAI,CAACA,OAAO,CAACvB,GAAG,EAAEuB,OAAO,CAAC;IAC1B,KAAK,IAAIO,GAAG,IAAIP,OAAO,EAAE;MACrBlB,GAAG,CAAC0B,WAAW,CAACD,GAAG,EAAEE,MAAM,CAACT,OAAO,CAACO,GAAG,CAAC,CAAC,CAAC;IAC9C;IACA,MAAMG,KAAK,GAAIL,MAAM,IAAK;MACtB,IAAI,CAACM,MAAM,CAACN,MAAM,CAACO,QAAQ,CAAC,CAAC,CAAC;MAC9B,IAAI,CAACC,oBAAoB,CAAC,CAAC;MAC3B/B,GAAG,CAACgC,IAAI,CAAC,MAAM;QACXhC,GAAG,CAACK,GAAG,CAAC,IAAI,CAAC;MACjB,CAAC,CAAC;IACN,CAAC;IACDL,GAAG,CAACU,SAAS,CAAC,MAAM;MAChB,IAAI,CAACqB,oBAAoB,CAAC,CAAC;MAC3B,IAAI,CAACzB,OAAO,CAAC,4CAA4C,CAAC;IAC9D,CAAC,CAAC;IACFN,GAAG,CAAC6B,MAAM,CAAC,CAACI,WAAW,EAAEC,MAAM,KAAK;MAChC,MAAMC,WAAW,GAAGX,MAAM,GAAGS,WAAW,CAACG,UAAU;MACnD,IAAID,WAAW,GAAGnB,qBAAqB,EAAE;QACrC,IAAI,CAACV,OAAO,CAAC,yBAAyB,CAAC;QACvCN,GAAG,CAACqC,KAAK,CAAC,CAAC,CAAC,CAAC;QACb;MACJ;MACA,IAAI,CAACd,MAAM,EAAE;QACT,IAAIW,MAAM,EAAE;UACRN,KAAK,CAACU,MAAM,CAACC,IAAI,CAACN,WAAW,CAAC,CAAC;UAC/B;QACJ;QACAV,MAAM,GAAGe,MAAM,CAACE,WAAW,CAACxB,qBAAqB,CAAC;MACtD;MACAsB,MAAM,CAACC,IAAI,CAACN,WAAW,CAAC,CAACQ,IAAI,CAAClB,MAAM,EAAEC,MAAM,CAAC;MAC7C,IAAIU,MAAM,EAAE;QACR,IAAIC,WAAW,IAAInB,qBAAqB,EAAE;UACtC,IAAI,CAACV,OAAO,CAAC,yBAAyB,CAAC;UACvCN,GAAG,CAACI,WAAW,CAAC,6BAA6B,CAAC,CAACC,GAAG,CAAC,CAAC;UACpD,IAAI,CAAC0B,oBAAoB,CAAC,CAAC;UAC3B;QACJ;QACAH,KAAK,CAACL,MAAM,CAAC;QACb;MACJ;MACAC,MAAM,GAAGW,WAAW;IACxB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACIJ,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAAChB,OAAO,GAAG,IAAI,CAACO,OAAO,GAAG,IAAI;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIO,MAAMA,CAACa,IAAI,EAAE;IACTxD,KAAK,CAAC,eAAe,EAAEwD,IAAI,CAAC;IAC5B,MAAMC,QAAQ,GAAIC,MAAM,IAAK;MACzB,IAAI,OAAO,KAAKA,MAAM,CAAC9B,IAAI,EAAE;QACzB5B,KAAK,CAAC,sBAAsB,CAAC;QAC7B,IAAI,CAACqB,OAAO,CAAC,CAAC;QACd,OAAO,KAAK;MAChB;MACA,IAAI,CAACsC,QAAQ,CAACD,MAAM,CAAC;IACzB,CAAC;IACD,IAAI,IAAI,CAACvB,QAAQ,KAAK,CAAC,EAAE;MACrB,IAAI,CAACyB,MAAM,CAACC,aAAa,CAACL,IAAI,EAAEC,QAAQ,CAAC;IAC7C,CAAC,MACI;MACD,IAAI,CAACG,MAAM,CAACC,aAAa,CAACL,IAAI,CAAC,CAACM,OAAO,CAACL,QAAQ,CAAC;IACrD;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIpC,OAAOA,CAAA,EAAG;IACN,IAAI,IAAI,CAACC,QAAQ,EAAE;MACf;MACA,IAAI,CAACK,IAAI,CAAC,CAAC;QAAEC,IAAI,EAAE;MAAO,CAAC,CAAC,CAAC;IACjC;IACA,KAAK,CAACP,OAAO,CAAC,CAAC;EACnB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIM,IAAIA,CAACoC,OAAO,EAAE;IACV,IAAI,CAACzC,QAAQ,GAAG,KAAK;IACrB,IAAI,IAAI,CAACI,WAAW,EAAE;MAClB1B,KAAK,CAAC,mCAAmC,CAAC;MAC1C+D,OAAO,CAACC,IAAI,CAAC;QAAEpC,IAAI,EAAE;MAAQ,CAAC,CAAC;MAC/B,IAAI,CAACF,WAAW,CAAC,CAAC;MAClB,IAAI,CAACA,WAAW,GAAG,IAAI;IAC3B;IACA,MAAMuC,OAAO,GAAIT,IAAI,IAAK;MACtB,MAAMU,QAAQ,GAAGH,OAAO,CAACI,IAAI,CAAET,MAAM,IAAK;QACtC,OAAOA,MAAM,CAACU,OAAO,IAAIV,MAAM,CAACU,OAAO,CAACF,QAAQ;MACpD,CAAC,CAAC;MACF,IAAI,CAACG,KAAK,CAACb,IAAI,EAAE;QAAEU;MAAS,CAAC,CAAC;IAClC,CAAC;IACD,IAAI,IAAI,CAAC/B,QAAQ,KAAK,CAAC,EAAE;MACrB,IAAI,CAACyB,MAAM,CAACU,aAAa,CAACP,OAAO,EAAE,IAAI,CAACQ,cAAc,EAAEN,OAAO,CAAC;IACpE,CAAC,MACI;MACD,IAAI,CAACL,MAAM,CAACU,aAAa,CAACP,OAAO,EAAEE,OAAO,CAAC;IAC/C;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACII,KAAKA,CAACb,IAAI,EAAEY,OAAO,EAAE;IACjBpE,KAAK,CAAC,cAAc,EAAEwD,IAAI,CAAC;IAC3B,IAAI,CAACS,OAAO,CAACT,IAAI,EAAEY,OAAO,EAAE,MAAM;MAC9B,IAAI,CAAC3D,GAAG,CAACc,OAAO,CAAC,CAAC;IACtB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACI0C,OAAOA,CAACT,IAAI,EAAEY,OAAO,EAAEX,QAAQ,EAAE;IAC7B;IACA,MAAMe,QAAQ,GAAG,OAAOhB,IAAI,KAAK,QAAQ;IACzC,MAAMiB,WAAW,GAAGD,QAAQ,GACtB,2BAA2B,GAC3B,0BAA0B;IAChC,MAAMxC,OAAO,GAAG;MACZ,cAAc,EAAEyC;IACpB,CAAC;IACD,MAAMC,OAAO,GAAIlB,IAAI,IAAK;MACtB,IAAI,CAACxB,OAAO,CAAC,IAAI,CAACvB,GAAG,EAAEuB,OAAO,CAAC;MAC/B,IAAI,CAAClB,GAAG,CAACgC,IAAI,CAAC,MAAM;QAChBxD,MAAM,CAACqF,IAAI,CAAC3C,OAAO,CAAC,CAAC8B,OAAO,CAAEvB,GAAG,IAAK;UAClC,IAAI,CAACzB,GAAG,CAAC0B,WAAW,CAACD,GAAG,EAAEE,MAAM,CAACT,OAAO,CAACO,GAAG,CAAC,CAAC,CAAC;QACnD,CAAC,CAAC;QACF,IAAI,CAACzB,GAAG,CAACK,GAAG,CAACqC,IAAI,CAAC;MACtB,CAAC,CAAC;MACFC,QAAQ,CAAC,CAAC;IACd,CAAC;IACD,IAAI,CAAC,IAAI,CAACmB,eAAe,IAAI,CAACR,OAAO,CAACF,QAAQ,EAAE;MAC5CQ,OAAO,CAAClB,IAAI,CAAC;MACb;IACJ;IACA,MAAMqB,GAAG,GAAGL,QAAQ,GAAGpB,MAAM,CAACF,UAAU,CAACM,IAAI,CAAC,GAAGA,IAAI,CAACsB,MAAM;IAC5D,IAAID,GAAG,GAAG,IAAI,CAACD,eAAe,CAACG,SAAS,EAAE;MACtCL,OAAO,CAAClB,IAAI,CAAC;MACb;IACJ;IACA,MAAMwB,QAAQ,GAAGlF,OAAO,CAAC,IAAI,CAACW,GAAG,CAAC,CAACwE,SAAS,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACjE,IAAI,CAACD,QAAQ,EAAE;MACXN,OAAO,CAAClB,IAAI,CAAC;MACb;IACJ;IACA,IAAI,CAACU,QAAQ,CAACV,IAAI,EAAEwB,QAAQ,EAAE,CAACE,GAAG,EAAE1B,IAAI,KAAK;MACzC,IAAI0B,GAAG,EAAE;QACL,IAAI,CAACpE,GAAG,CAACI,WAAW,CAAC,2BAA2B,CAAC;QACjD,IAAI,CAACJ,GAAG,CAACK,GAAG,CAAC,CAAC;QACdsC,QAAQ,CAACyB,GAAG,CAAC;QACb;MACJ;MACAlD,OAAO,CAAC,kBAAkB,CAAC,GAAGgD,QAAQ;MACtCN,OAAO,CAAClB,IAAI,CAAC;IACjB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACIU,QAAQA,CAACV,IAAI,EAAEwB,QAAQ,EAAEvB,QAAQ,EAAE;IAC/BzD,KAAK,CAAC,aAAa,CAAC;IACpB,MAAMmF,OAAO,GAAG,EAAE;IAClB,IAAIC,KAAK,GAAG,CAAC;IACblF,kBAAkB,CAAC8E,QAAQ,CAAC,CAAC,IAAI,CAACJ,eAAe,CAAC,CAC7CS,EAAE,CAAC,OAAO,EAAE5B,QAAQ,CAAC,CACrB4B,EAAE,CAAC,MAAM,EAAE,UAAUC,KAAK,EAAE;MAC7BH,OAAO,CAACnB,IAAI,CAACsB,KAAK,CAAC;MACnBF,KAAK,IAAIE,KAAK,CAACR,MAAM;IACzB,CAAC,CAAC,CACGO,EAAE,CAAC,KAAK,EAAE,YAAY;MACvB5B,QAAQ,CAAC,IAAI,EAAEL,MAAM,CAACmC,MAAM,CAACJ,OAAO,EAAEC,KAAK,CAAC,CAAC;IACjD,CAAC,CAAC,CACGjE,GAAG,CAACqC,IAAI,CAAC;EAClB;EACA;AACJ;AACA;AACA;AACA;EACIgC,OAAOA,CAACC,EAAE,EAAE;IACRzF,KAAK,CAAC,SAAS,CAAC;IAChB,IAAI0F,iBAAiB;IACrB,MAAMrE,OAAO,GAAGA,CAAA,KAAM;MAClBsE,YAAY,CAACD,iBAAiB,CAAC;MAC/BD,EAAE,CAAC,CAAC;MACJ,IAAI,CAACpE,OAAO,CAAC,CAAC;IAClB,CAAC;IACD,IAAI,IAAI,CAACC,QAAQ,EAAE;MACftB,KAAK,CAAC,yCAAyC,CAAC;MAChD,IAAI,CAAC2B,IAAI,CAAC,CAAC;QAAEC,IAAI,EAAE;MAAQ,CAAC,CAAC,CAAC;MAC9BP,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAI,IAAI,CAACuE,SAAS,EAAE;MACrB5F,KAAK,CAAC,0CAA0C,CAAC;MACjDqB,OAAO,CAAC,CAAC;IACb,CAAC,MACI;MACDrB,KAAK,CAAC,kDAAkD,CAAC;MACzD,IAAI,CAAC0B,WAAW,GAAGL,OAAO;MAC1BqE,iBAAiB,GAAGG,UAAU,CAACxE,OAAO,EAAE,IAAI,CAACX,YAAY,CAAC;IAC9D;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIsB,OAAOA,CAACvB,GAAG,EAAEuB,OAAO,EAAE;IAClBA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB;IACA;IACA,MAAM8D,EAAE,GAAGrF,GAAG,CAACuB,OAAO,CAAC,YAAY,CAAC;IACpC,IAAI8D,EAAE,KAAK,CAACA,EAAE,CAACC,OAAO,CAAC,OAAO,CAAC,IAAI,CAACD,EAAE,CAACC,OAAO,CAAC,UAAU,CAAC,CAAC,EAAE;MACzD/D,OAAO,CAAC,kBAAkB,CAAC,GAAG,GAAG;IACrC;IACAA,OAAO,CAAC,eAAe,CAAC,GAAG,UAAU;IACrC,IAAI,CAACP,IAAI,CAAC,SAAS,EAAEO,OAAO,EAAEvB,GAAG,CAAC;IAClC,OAAOuB,OAAO;EAClB;AACJ;AACAxC,OAAO,CAACE,OAAO,GAAGA,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}