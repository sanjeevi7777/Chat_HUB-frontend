{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polling = void 0;\nconst transport_1 = require(\"../transport\");\nconst zlib_1 = require(\"zlib\");\nconst accepts = require(\"accepts\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n  gzip: zlib_1.createGzip,\n  deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  constructor(req) {\n    super(req);\n    this.closeTimeout = 30 * 1000;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n  get name() {\n    return \"polling\";\n  }\n  get supportsFraming() {\n    return false;\n  }\n  /**\n   * Overrides onRequest.\n   *\n   * @param {http.IncomingMessage}\n   * @api private\n   */\n  onRequest(req) {\n    const res = req.res;\n    // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n    req.res = null;\n    if (\"GET\" === req.method) {\n      this.onPollRequest(req, res);\n    } else if (\"POST\" === req.method) {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeHead(500);\n      res.end();\n    }\n  }\n  /**\n   * The client sends a request awaiting for us to send data.\n   *\n   * @api private\n   */\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\");\n      // assert: this.res, '.req and .res should be (un)set together'\n      this.onError(\"overlap from client\");\n      res.writeHead(400);\n      res.end();\n      return;\n    }\n    debug(\"setting request\");\n    this.req = req;\n    this.res = res;\n    const onClose = () => {\n      this.onError(\"poll connection closed prematurely\");\n    };\n    const cleanup = () => {\n      req.removeListener(\"close\", onClose);\n      this.req = this.res = null;\n    };\n    req.cleanup = cleanup;\n    req.on(\"close\", onClose);\n    this.writable = true;\n    this.emit(\"drain\");\n    // if we're still writable but had a pending close, trigger an empty send\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n  }\n  /**\n   * The client sends a request with data.\n   *\n   * @api private\n   */\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeHead(400);\n      res.end();\n      return;\n    }\n    const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n    if (isBinary && this.protocol === 4) {\n      return this.onError(\"invalid content\");\n    }\n    this.dataReq = req;\n    this.dataRes = res;\n    let chunks = isBinary ? Buffer.concat([]) : \"\";\n    const cleanup = () => {\n      req.removeListener(\"data\", onData);\n      req.removeListener(\"end\", onEnd);\n      req.removeListener(\"close\", onClose);\n      this.dataReq = this.dataRes = chunks = null;\n    };\n    const onClose = () => {\n      cleanup();\n      this.onError(\"data request connection closed prematurely\");\n    };\n    const onData = data => {\n      let contentLength;\n      if (isBinary) {\n        chunks = Buffer.concat([chunks, data]);\n        contentLength = chunks.length;\n      } else {\n        chunks += data;\n        contentLength = Buffer.byteLength(chunks);\n      }\n      if (contentLength > this.maxHttpBufferSize) {\n        res.writeHead(413).end();\n        cleanup();\n      }\n    };\n    const onEnd = () => {\n      this.onData(chunks);\n      const headers = {\n        // text/html is required instead of text/plain to avoid an\n        // unwanted download dialog on certain user-agents (GH-43)\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": 2\n      };\n      res.writeHead(200, this.headers(req, headers));\n      res.end(\"ok\");\n      cleanup();\n    };\n    req.on(\"close\", onClose);\n    if (!isBinary) req.setEncoding(\"utf8\");\n    req.on(\"data\", onData);\n    req.on(\"end\", onEnd);\n  }\n  /**\n   * Processes the incoming data payload.\n   *\n   * @param {String} encoded payload\n   * @api private\n   */\n  onData(data) {\n    debug('received \"%s\"', data);\n    const callback = packet => {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        this.onClose();\n        return false;\n      }\n      this.onPacket(packet);\n    };\n    if (this.protocol === 3) {\n      this.parser.decodePayload(data, callback);\n    } else {\n      this.parser.decodePayload(data).forEach(callback);\n    }\n  }\n  /**\n   * Overrides onClose.\n   *\n   * @api private\n   */\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n    super.onClose();\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n  send(packets) {\n    this.writable = false;\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({\n        type: \"close\"\n      });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n    const doWrite = data => {\n      const compress = packets.some(packet => {\n        return packet.options && packet.options.compress;\n      });\n      this.write(data, {\n        compress\n      });\n    };\n    if (this.protocol === 3) {\n      this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n    } else {\n      this.parser.encodePayload(packets, doWrite);\n    }\n  }\n  /**\n   * Writes data as response to poll request.\n   *\n   * @param {String} data\n   * @param {Object} options\n   * @api private\n   */\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    this.doWrite(data, options, () => {\n      this.req.cleanup();\n    });\n  }\n  /**\n   * Performs the write.\n   *\n   * @api private\n   */\n  doWrite(data, options, callback) {\n    // explicit UTF-8 is required for pages not served under utf\n    const isString = typeof data === \"string\";\n    const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n    const headers = {\n      \"Content-Type\": contentType\n    };\n    const respond = data => {\n      headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n      this.res.writeHead(200, this.headers(this.req, headers));\n      this.res.end(data);\n      callback();\n    };\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n    const len = isString ? Buffer.byteLength(data) : data.length;\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n    this.compress(data, encoding, (err, data) => {\n      if (err) {\n        this.res.writeHead(500);\n        this.res.end();\n        callback(err);\n        return;\n      }\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n  }\n  /**\n   * Compresses data.\n   *\n   * @api private\n   */\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n    const buffers = [];\n    let nread = 0;\n    compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }).on(\"end\", function () {\n      callback(null, Buffer.concat(buffers, nread));\n    }).end(data);\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n  doClose(fn) {\n    debug(\"closing\");\n    let closeTimeoutTimer;\n    if (this.dataReq) {\n      debug(\"aborting ongoing data request\");\n      this.dataReq.destroy();\n    }\n    const onClose = () => {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      this.onClose();\n    };\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{\n        type: \"close\"\n      }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n  }\n  /**\n   * Returns headers for a response.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {Object} extra headers\n   * @api private\n   */\n  headers(req, headers) {\n    headers = headers || {};\n    // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n    const ua = req.headers[\"user-agent\"];\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n    headers[\"cache-control\"] = \"no-store\";\n    this.emit(\"headers\", headers, req);\n    return headers;\n  }\n}\nexports.Polling = Polling;","map":{"version":3,"names":["Object","defineProperty","exports","value","Polling","transport_1","require","zlib_1","accepts","debug_1","debug","default","compressionMethods","gzip","createGzip","deflate","createDeflate","Transport","constructor","req","closeTimeout","name","supportsFraming","onRequest","res","method","onPollRequest","onDataRequest","writeHead","end","onError","onClose","cleanup","removeListener","on","writable","emit","shouldClose","send","type","dataReq","isBinary","headers","protocol","dataRes","chunks","Buffer","concat","onData","onEnd","data","contentLength","length","byteLength","maxHttpBufferSize","setEncoding","callback","packet","onPacket","parser","decodePayload","forEach","packets","push","doWrite","compress","some","options","write","encodePayload","supportsBinary","isString","contentType","respond","httpCompression","len","threshold","encoding","encodings","err","buffers","nread","chunk","doClose","fn","closeTimeoutTimer","destroy","clearTimeout","discarded","setTimeout","ua","indexOf"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/engine.io/build/transports/polling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polling = void 0;\nconst transport_1 = require(\"../transport\");\nconst zlib_1 = require(\"zlib\");\nconst accepts = require(\"accepts\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate,\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     *\n     * @api public.\n     */\n    constructor(req) {\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     *\n     * @api public\n     */\n    get name() {\n        return \"polling\";\n    }\n    get supportsFraming() {\n        return false;\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param {http.IncomingMessage}\n     * @api private\n     */\n    onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (\"GET\" === req.method) {\n            this.onPollRequest(req, res);\n        }\n        else if (\"POST\" === req.method) {\n            this.onDataRequest(req, res);\n        }\n        else {\n            res.writeHead(500);\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @api private\n     */\n    onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = () => {\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = () => {\n            req.removeListener(\"close\", onClose);\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        req.on(\"close\", onClose);\n        this.writable = true;\n        this.emit(\"drain\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([{ type: \"noop\" }]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @api private\n     */\n    onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let chunks = isBinary ? Buffer.concat([]) : \"\";\n        const cleanup = () => {\n            req.removeListener(\"data\", onData);\n            req.removeListener(\"end\", onEnd);\n            req.removeListener(\"close\", onClose);\n            this.dataReq = this.dataRes = chunks = null;\n        };\n        const onClose = () => {\n            cleanup();\n            this.onError(\"data request connection closed prematurely\");\n        };\n        const onData = (data) => {\n            let contentLength;\n            if (isBinary) {\n                chunks = Buffer.concat([chunks, data]);\n                contentLength = chunks.length;\n            }\n            else {\n                chunks += data;\n                contentLength = Buffer.byteLength(chunks);\n            }\n            if (contentLength > this.maxHttpBufferSize) {\n                res.writeHead(413).end();\n                cleanup();\n            }\n        };\n        const onEnd = () => {\n            this.onData(chunks);\n            const headers = {\n                // text/html is required instead of text/plain to avoid an\n                // unwanted download dialog on certain user-agents (GH-43)\n                \"Content-Type\": \"text/html\",\n                \"Content-Length\": 2,\n            };\n            res.writeHead(200, this.headers(req, headers));\n            res.end(\"ok\");\n            cleanup();\n        };\n        req.on(\"close\", onClose);\n        if (!isBinary)\n            req.setEncoding(\"utf8\");\n        req.on(\"data\", onData);\n        req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @api private\n     */\n    onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet) => {\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        }\n        else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @api private\n     */\n    onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([{ type: \"noop\" }]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({ type: \"close\" });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data) => {\n            const compress = packets.some((packet) => {\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, { compress });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        }\n        else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @api private\n     */\n    write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, () => {\n            this.req.cleanup();\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @api private\n     */\n    doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString\n            ? \"text/plain; charset=UTF-8\"\n            : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType,\n        };\n        const respond = (data) => {\n            headers[\"Content-Length\"] =\n                \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            this.res.writeHead(200, this.headers(this.req, headers));\n            this.res.end(data);\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data) => {\n            if (err) {\n                this.res.writeHead(500);\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @api private\n     */\n    compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression)\n            .on(\"error\", callback)\n            .on(\"data\", function (chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        })\n            .on(\"end\", function () {\n            callback(null, Buffer.concat(buffers, nread));\n        })\n            .end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        if (this.dataReq) {\n            debug(\"aborting ongoing data request\");\n            this.dataReq.destroy();\n        }\n        const onClose = () => {\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([{ type: \"close\" }]);\n            onClose();\n        }\n        else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        }\n        else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {Object} extra headers\n     * @api private\n     */\n    headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}