{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uServer = void 0;\nconst debug_1 = require(\"debug\");\nconst server_1 = require(\"./server\");\nconst transports_uws_1 = require(\"./transports-uws\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\nclass uServer extends server_1.BaseServer {\n  init() {}\n  cleanup() {}\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req, res) {\n    req.method = req.getMethod().toUpperCase();\n    req.url = req.getUrl();\n    const params = new URLSearchParams(req.getQuery());\n    req._query = Object.fromEntries(params.entries());\n    req.headers = {};\n    req.forEach((key, value) => {\n      req.headers[key] = value;\n    });\n    req.connection = {\n      remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n    };\n    res.onAborted(() => {\n      debug(\"response has been aborted\");\n    });\n  }\n  createTransport(transportName, req) {\n    return new transports_uws_1.default[transportName](req);\n  }\n  /**\n   * Attach the engine to a µWebSockets.js server\n   * @param app\n   * @param options\n   */\n  attach(app /* : TemplatedApp */, options = {}) {\n    const path = this._computePath(options);\n    app.any(path, this.handleRequest.bind(this))\n    //\n    .ws(path, {\n      compression: options.compression,\n      idleTimeout: options.idleTimeout,\n      maxBackpressure: options.maxBackpressure,\n      maxPayloadLength: this.opts.maxHttpBufferSize,\n      upgrade: this.handleUpgrade.bind(this),\n      open: ws => {\n        const transport = ws.getUserData().transport;\n        transport.socket = ws;\n        transport.writable = true;\n        transport.emit(\"drain\");\n      },\n      message: (ws, message, isBinary) => {\n        ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n      },\n      close: (ws, code, message) => {\n        ws.getUserData().transport.onClose(code, message);\n      }\n    });\n  }\n  _applyMiddlewares(req, res, callback) {\n    if (this.middlewares.length === 0) {\n      return callback();\n    }\n    // needed to buffer headers until the status is computed\n    req.res = new ResponseWrapper(res);\n    super._applyMiddlewares(req, req.res, err => {\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      req.res.writeHead();\n      callback(err);\n    });\n  }\n  handleRequest(res, req) {\n    debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n    this.prepare(req, res);\n    req.res = res;\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(req.res, errorCode, errorContext);\n        return;\n      }\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(server_1.Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n  handleUpgrade(res, req, context) {\n    debug(\"on upgrade\");\n    this.prepare(req, res);\n    req.res = res;\n    const callback = async (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(res, errorCode, errorContext);\n        return;\n      }\n      const id = req._query.sid;\n      let transport;\n      if (id) {\n        const client = this.clients[id];\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          res.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          res.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          res.close();\n        } else {\n          debug(\"upgrading existing transport\");\n          transport = this.createTransport(req._query.transport, req);\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n        if (!transport) {\n          return;\n        }\n      }\n      // calling writeStatus() triggers the flushing of any header added in a middleware\n      req.res.writeStatus(\"101 Switching Protocols\");\n      res.upgrade({\n        transport\n      }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n    };\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(server_1.Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n  abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n    const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n    res.writeStatus(statusCode);\n    res.writeHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify({\n      code: errorCode,\n      message\n    }));\n  }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n  constructor(res) {\n    this.res = res;\n    this.statusWritten = false;\n    this.headers = [];\n    this.isAborted = false;\n  }\n  set statusCode(status) {\n    if (!status) {\n      return;\n    }\n    // FIXME: handle all status codes?\n    this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n  }\n  writeHead(status) {\n    this.statusCode = status;\n  }\n  setHeader(key, value) {\n    if (Array.isArray(value)) {\n      value.forEach(val => {\n        this.writeHeader(key, val);\n      });\n    } else {\n      this.writeHeader(key, value);\n    }\n  }\n  removeHeader() {\n    // FIXME: not implemented\n  }\n  // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n  getHeader() {}\n  writeStatus(status) {\n    if (this.isAborted) return;\n    this.res.writeStatus(status);\n    this.statusWritten = true;\n    this.writeBufferedHeaders();\n    return this;\n  }\n  writeHeader(key, value) {\n    if (this.isAborted) return;\n    if (key === \"Content-Length\") {\n      // the content length is automatically added by uWebSockets.js\n      return;\n    }\n    if (this.statusWritten) {\n      this.res.writeHeader(key, value);\n    } else {\n      this.headers.push([key, value]);\n    }\n  }\n  writeBufferedHeaders() {\n    this.headers.forEach(([key, value]) => {\n      this.res.writeHeader(key, value);\n    });\n  }\n  end(data) {\n    if (this.isAborted) return;\n    this.res.cork(() => {\n      if (!this.statusWritten) {\n        // status will be inferred as \"200 OK\"\n        this.writeBufferedHeaders();\n      }\n      this.res.end(data);\n    });\n  }\n  onData(fn) {\n    if (this.isAborted) return;\n    this.res.onData(fn);\n  }\n  onAborted(fn) {\n    if (this.isAborted) return;\n    this.res.onAborted(() => {\n      // Any attempt to use the UWS response object after abort will throw!\n      this.isAborted = true;\n      fn();\n    });\n  }\n  cork(fn) {\n    if (this.isAborted) return;\n    this.res.cork(fn);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","uServer","debug_1","require","server_1","transports_uws_1","debug","default","BaseServer","init","cleanup","prepare","req","res","method","getMethod","toUpperCase","url","getUrl","params","URLSearchParams","getQuery","_query","fromEntries","entries","headers","forEach","key","connection","remoteAddress","Buffer","from","getRemoteAddressAsText","toString","onAborted","createTransport","transportName","attach","app","options","path","_computePath","any","handleRequest","bind","ws","compression","idleTimeout","maxBackpressure","maxPayloadLength","opts","maxHttpBufferSize","upgrade","handleUpgrade","open","transport","getUserData","socket","writable","emit","message","isBinary","onData","close","code","onClose","_applyMiddlewares","callback","middlewares","length","ResponseWrapper","err","writeHead","errorCode","errorContext","undefined","Server","errorMessages","context","abortRequest","sid","clients","onRequest","closeConnection","handshake","errors","BAD_REQUEST","name","verify","id","client","upgrading","upgraded","maybeUpgrade","writeStatus","getHeader","statusCode","FORBIDDEN","writeHeader","end","JSON","stringify","constructor","statusWritten","isAborted","status","setHeader","Array","isArray","val","removeHeader","writeBufferedHeaders","push","data","cork","fn"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/engine.io/build/userver.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uServer = void 0;\nconst debug_1 = require(\"debug\");\nconst server_1 = require(\"./server\");\nconst transports_uws_1 = require(\"./transports-uws\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\nclass uServer extends server_1.BaseServer {\n    init() { }\n    cleanup() { }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        req.url = req.getUrl();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value) => {\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),\n        };\n        res.onAborted(() => {\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a µWebSockets.js server\n     * @param app\n     * @param options\n     */\n    attach(app /* : TemplatedApp */, options = {}) {\n        const path = this._computePath(options);\n        app\n            .any(path, this.handleRequest.bind(this))\n            //\n            .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: (ws) => {\n                const transport = ws.getUserData().transport;\n                transport.socket = ws;\n                transport.writable = true;\n                transport.emit(\"drain\");\n            },\n            message: (ws, message, isBinary) => {\n                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message) => {\n                ws.getUserData().transport.onClose(code, message);\n            },\n        });\n    }\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            return callback();\n        }\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        super._applyMiddlewares(req, req.res, (err) => {\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            req.res.writeHead();\n            callback(err);\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        req.res = res;\n        const callback = async (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    res.close();\n                }\n                else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    res.close();\n                }\n                else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    res.close();\n                }\n                else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client.maybeUpgrade(transport);\n                }\n            }\n            else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            // calling writeStatus() triggers the flushing of any header added in a middleware\n            req.res.writeStatus(\"101 Switching Protocols\");\n            res.upgrade({\n                transport,\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN\n            ? \"403 Forbidden\"\n            : \"400 Bad Request\";\n        const message = errorContext && errorContext.message\n            ? errorContext.message\n            : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message,\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res) {\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n        this.isAborted = false;\n    }\n    set statusCode(status) {\n        if (!status) {\n            return;\n        }\n        // FIXME: handle all status codes?\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    writeHead(status) {\n        this.statusCode = status;\n    }\n    setHeader(key, value) {\n        if (Array.isArray(value)) {\n            value.forEach((val) => {\n                this.writeHeader(key, val);\n            });\n        }\n        else {\n            this.writeHeader(key, value);\n        }\n    }\n    removeHeader() {\n        // FIXME: not implemented\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() { }\n    writeStatus(status) {\n        if (this.isAborted)\n            return;\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n        return this;\n    }\n    writeHeader(key, value) {\n        if (this.isAborted)\n            return;\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        }\n        else {\n            this.headers.push([key, value]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value]) => {\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (this.isAborted)\n            return;\n        this.res.cork(() => {\n            if (!this.statusWritten) {\n                // status will be inferred as \"200 OK\"\n                this.writeBufferedHeaders();\n            }\n            this.res.end(data);\n        });\n    }\n    onData(fn) {\n        if (this.isAborted)\n            return;\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        if (this.isAborted)\n            return;\n        this.res.onAborted(() => {\n            // Any attempt to use the UWS response object after abort will throw!\n            this.isAborted = true;\n            fn();\n        });\n    }\n    cork(fn) {\n        if (this.isAborted)\n            return;\n        this.res.cork(fn);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}