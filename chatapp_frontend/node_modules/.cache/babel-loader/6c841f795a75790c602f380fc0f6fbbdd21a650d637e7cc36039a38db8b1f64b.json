{"ast":null,"code":"/*!\n * base64id v0.1.0\n */\n\n/**\n * Module dependencies\n */\n\nvar crypto = require('crypto');\n\n/**\n * Constructor\n */\n\nvar Base64Id = function () {};\n\n/**\n * Get random bytes\n *\n * Uses a buffer if available, falls back to crypto.randomBytes\n */\n\nBase64Id.prototype.getRandomBytes = function (bytes) {\n  var BUFFER_SIZE = 4096;\n  var self = this;\n  bytes = bytes || 12;\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);\n  var threshold = parseInt(bytesInBuffer * 0.85);\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n  if (this.bytesBufferIndex == null) {\n    this.bytesBufferIndex = -1;\n  }\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  }\n\n  // No buffered bytes available or index above threshold\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      });\n    }\n\n    // Fall back to sync call when no buffered bytes are available\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));\n  this.bytesBufferIndex++;\n  return result;\n};\n\n/**\n * Generates a base64 id\n *\n * (Original version from socket.io <http://socket.io>)\n */\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n  this.sequenceNumber = this.sequenceNumber + 1 | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function (i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\n/**\n * Export\n */\n\nexports = module.exports = new Base64Id();","map":{"version":3,"names":["crypto","require","Base64Id","prototype","getRandomBytes","bytes","BUFFER_SIZE","self","randomBytes","bytesInBuffer","parseInt","threshold","bytesBufferIndex","bytesBuffer","isGeneratingBytes","err","result","slice","generateId","rand","Buffer","alloc","writeInt32BE","Math","abs","random","Date","now","toString","sequenceNumber","copy","forEach","i","pow","replace","exports","module"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/base64id/lib/base64id.js"],"sourcesContent":["/*!\n * base64id v0.1.0\n */\n\n/**\n * Module dependencies\n */\n\nvar crypto = require('crypto');\n\n/**\n * Constructor\n */\n\nvar Base64Id = function() { };\n\n/**\n * Get random bytes\n *\n * Uses a buffer if available, falls back to crypto.randomBytes\n */\n\nBase64Id.prototype.getRandomBytes = function(bytes) {\n\n  var BUFFER_SIZE = 4096\n  var self = this;  \n  \n  bytes = bytes || 12;\n\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n  \n  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);\n  var threshold = parseInt(bytesInBuffer*0.85);\n\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n\n  if (this.bytesBufferIndex == null) {\n     this.bytesBufferIndex = -1;\n  }\n\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  }\n\n  // No buffered bytes available or index above threshold\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n     \n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      }); \n    }\n    \n    // Fall back to sync call when no buffered bytes are available\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n  \n  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); \n  this.bytesBufferIndex++; \n  \n  return result;\n}\n\n/**\n * Generates a base64 id\n *\n * (Original version from socket.io <http://socket.io>)\n */\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()\n      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n  this.sequenceNumber = (this.sequenceNumber + 1) | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function(i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\n/**\n * Export\n */\n\nexports = module.exports = new Base64Id();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}