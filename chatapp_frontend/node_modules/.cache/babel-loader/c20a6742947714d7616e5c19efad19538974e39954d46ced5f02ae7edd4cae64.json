{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = void 0;\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"debug\");\nconst timers_1 = require(\"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  constructor(id, server, transport, req, protocol) {\n    super();\n    this._readyState = \"opening\";\n    this.upgrading = false;\n    this.upgraded = false;\n    this.writeBuffer = [];\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.cleanupFn = [];\n    this.id = id;\n    this.server = server;\n    this.request = req;\n    this.protocol = protocol;\n    // Cache IP since it might not be in the req later\n    if (req) {\n      if (req.websocket && req.websocket._socket) {\n        this.remoteAddress = req.websocket._socket.remoteAddress;\n      } else {\n        this.remoteAddress = req.connection.remoteAddress;\n      }\n    } else {\n      // TODO there is currently no way to get the IP address of the client when it connects with WebTransport\n      //  see https://github.com/fails-components/webtransport/issues/114\n    }\n    this.pingTimeoutTimer = null;\n    this.pingIntervalTimer = null;\n    this.setTransport(transport);\n    this.onOpen();\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  set readyState(state) {\n    debug(\"readyState updated from %s to %s\", this._readyState, state);\n    this._readyState = state;\n  }\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n  onOpen() {\n    this.readyState = \"open\";\n    // sends an `open` packet\n    this.transport.sid = this.id;\n    this.sendPacket(\"open\", JSON.stringify({\n      sid: this.id,\n      upgrades: this.getAvailableUpgrades(),\n      pingInterval: this.server.opts.pingInterval,\n      pingTimeout: this.server.opts.pingTimeout,\n      maxPayload: this.server.opts.maxHttpBufferSize\n    }));\n    if (this.server.opts.initialPacket) {\n      this.sendPacket(\"message\", this.server.opts.initialPacket);\n    }\n    this.emit(\"open\");\n    if (this.protocol === 3) {\n      // in protocol v3, the client sends a ping, and the server answers with a pong\n      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n    } else {\n      // in protocol v4, the server sends a ping, and the client answers with a pong\n      this.schedulePing();\n    }\n  }\n  /**\n   * Called upon transport packet.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n  onPacket(packet) {\n    if (\"open\" !== this.readyState) {\n      return debug(\"packet received with closed socket\");\n    }\n    // export packet event\n    debug(`received packet ${packet.type}`);\n    this.emit(\"packet\", packet);\n    // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n    this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n    switch (packet.type) {\n      case \"ping\":\n        if (this.transport.protocol !== 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n        debug(\"got ping\");\n        this.sendPacket(\"pong\");\n        this.emit(\"heartbeat\");\n        break;\n      case \"pong\":\n        if (this.transport.protocol === 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n        debug(\"got pong\");\n        this.pingIntervalTimer.refresh();\n        this.emit(\"heartbeat\");\n        break;\n      case \"error\":\n        this.onClose(\"parse error\");\n        break;\n      case \"message\":\n        this.emit(\"data\", packet.data);\n        this.emit(\"message\", packet.data);\n        break;\n    }\n  }\n  /**\n   * Called upon transport error.\n   *\n   * @param {Error} err - error object\n   * @api private\n   */\n  onError(err) {\n    debug(\"transport error\");\n    this.onClose(\"transport error\", err);\n  }\n  /**\n   * Pings client every `this.pingInterval` and expects response\n   * within `this.pingTimeout` or closes connection.\n   *\n   * @api private\n   */\n  schedulePing() {\n    this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {\n      debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n      this.sendPacket(\"ping\");\n      this.resetPingTimeout(this.server.opts.pingTimeout);\n    }, this.server.opts.pingInterval);\n  }\n  /**\n   * Resets ping timeout.\n   *\n   * @api private\n   */\n  resetPingTimeout(timeout) {\n    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {\n      if (this.readyState === \"closed\") return;\n      this.onClose(\"ping timeout\");\n    }, timeout);\n  }\n  /**\n   * Attaches handlers for the given transport.\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n  setTransport(transport) {\n    const onError = this.onError.bind(this);\n    const onPacket = this.onPacket.bind(this);\n    const flush = this.flush.bind(this);\n    const onClose = this.onClose.bind(this, \"transport close\");\n    this.transport = transport;\n    this.transport.once(\"error\", onError);\n    this.transport.on(\"packet\", onPacket);\n    this.transport.on(\"drain\", flush);\n    this.transport.once(\"close\", onClose);\n    // this function will manage packet events (also message callbacks)\n    this.setupSendCallback();\n    this.cleanupFn.push(function () {\n      transport.removeListener(\"error\", onError);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"drain\", flush);\n      transport.removeListener(\"close\", onClose);\n    });\n  }\n  /**\n   * Upgrades socket to the given transport\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n  maybeUpgrade(transport) {\n    debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n    this.upgrading = true;\n    // set transport upgrade timer\n    const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {\n      debug(\"client did not complete upgrade - closing transport\");\n      cleanup();\n      if (\"open\" === transport.readyState) {\n        transport.close();\n      }\n    }, this.server.opts.upgradeTimeout);\n    let checkIntervalTimer;\n    const onPacket = packet => {\n      if (\"ping\" === packet.type && \"probe\" === packet.data) {\n        debug(\"got probe ping packet, sending pong\");\n        transport.send([{\n          type: \"pong\",\n          data: \"probe\"\n        }]);\n        this.emit(\"upgrading\", transport);\n        clearInterval(checkIntervalTimer);\n        checkIntervalTimer = setInterval(check, 100);\n      } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n        debug(\"got upgrade packet - upgrading\");\n        cleanup();\n        this.transport.discard();\n        this.upgraded = true;\n        this.clearTransport();\n        this.setTransport(transport);\n        this.emit(\"upgrade\", transport);\n        this.flush();\n        if (this.readyState === \"closing\") {\n          transport.close(() => {\n            this.onClose(\"forced close\");\n          });\n        }\n      } else {\n        cleanup();\n        transport.close();\n      }\n    };\n    // we force a polling cycle to ensure a fast upgrade\n    const check = () => {\n      if (\"polling\" === this.transport.name && this.transport.writable) {\n        debug(\"writing a noop packet to polling for fast upgrade\");\n        this.transport.send([{\n          type: \"noop\"\n        }]);\n      }\n    };\n    const cleanup = () => {\n      this.upgrading = false;\n      clearInterval(checkIntervalTimer);\n      (0, timers_1.clearTimeout)(upgradeTimeoutTimer);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"close\", onTransportClose);\n      transport.removeListener(\"error\", onError);\n      this.removeListener(\"close\", onClose);\n    };\n    const onError = err => {\n      debug(\"client did not complete upgrade - %s\", err);\n      cleanup();\n      transport.close();\n      transport = null;\n    };\n    const onTransportClose = () => {\n      onError(\"transport closed\");\n    };\n    const onClose = () => {\n      onError(\"socket closed\");\n    };\n    transport.on(\"packet\", onPacket);\n    transport.once(\"close\", onTransportClose);\n    transport.once(\"error\", onError);\n    this.once(\"close\", onClose);\n  }\n  /**\n   * Clears listeners and timers associated with current transport.\n   *\n   * @api private\n   */\n  clearTransport() {\n    let cleanup;\n    const toCleanUp = this.cleanupFn.length;\n    for (let i = 0; i < toCleanUp; i++) {\n      cleanup = this.cleanupFn.shift();\n      cleanup();\n    }\n    // silence further transport errors and prevent uncaught exceptions\n    this.transport.on(\"error\", function () {\n      debug(\"error triggered by discarded transport\");\n    });\n    // ensure transport won't stay open\n    this.transport.close();\n    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n  }\n  /**\n   * Called upon transport considered closed.\n   * Possible reasons: `ping timeout`, `client error`, `parse error`,\n   * `transport error`, `server close`, `transport close`\n   */\n  onClose(reason, description) {\n    if (\"closed\" !== this.readyState) {\n      this.readyState = \"closed\";\n      // clear timers\n      (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n      // clean writeBuffer in next tick, so developers can still\n      // grab the writeBuffer on 'close' event\n      process.nextTick(() => {\n        this.writeBuffer = [];\n      });\n      this.packetsFn = [];\n      this.sentCallbackFn = [];\n      this.clearTransport();\n      this.emit(\"close\", reason, description);\n    }\n  }\n  /**\n   * Setup and manage send callback\n   *\n   * @api private\n   */\n  setupSendCallback() {\n    // the message was sent successfully, execute the callback\n    const onDrain = () => {\n      if (this.sentCallbackFn.length > 0) {\n        const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n        if (\"function\" === typeof seqFn) {\n          debug(\"executing send callback\");\n          seqFn(this.transport);\n        } else if (Array.isArray(seqFn)) {\n          debug(\"executing batch send callback\");\n          const l = seqFn.length;\n          let i = 0;\n          for (; i < l; i++) {\n            if (\"function\" === typeof seqFn[i]) {\n              seqFn[i](this.transport);\n            }\n          }\n        }\n      }\n    };\n    this.transport.on(\"drain\", onDrain);\n    this.cleanupFn.push(() => {\n      this.transport.removeListener(\"drain\", onDrain);\n    });\n  }\n  /**\n   * Sends a message packet.\n   *\n   * @param {Object} data\n   * @param {Object} options\n   * @param {Function} callback\n   * @return {Socket} for chaining\n   * @api public\n   */\n  send(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n  /**\n   * Alias of {@link send}.\n   *\n   * @param data\n   * @param options\n   * @param callback\n   */\n  write(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} type - packet type\n   * @param {String} data\n   * @param {Object} options\n   * @param {Function} callback\n   *\n   * @api private\n   */\n  sendPacket(type, data, options = {}, callback) {\n    if (\"function\" === typeof options) {\n      callback = options;\n      options = {};\n    }\n    if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n      debug('sending packet \"%s\" (%s)', type, data);\n      // compression is enabled by default\n      options.compress = options.compress !== false;\n      const packet = {\n        type,\n        options: options\n      };\n      if (data) packet.data = data;\n      // exports packetCreate event\n      this.emit(\"packetCreate\", packet);\n      this.writeBuffer.push(packet);\n      // add send callback to object, if defined\n      if (callback) this.packetsFn.push(callback);\n      this.flush();\n    }\n  }\n  /**\n   * Attempts to flush the packets buffer.\n   *\n   * @api private\n   */\n  flush() {\n    if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n      debug(\"flushing buffer to transport\");\n      this.emit(\"flush\", this.writeBuffer);\n      this.server.emit(\"flush\", this, this.writeBuffer);\n      const wbuf = this.writeBuffer;\n      this.writeBuffer = [];\n      if (!this.transport.supportsFraming) {\n        this.sentCallbackFn.push(this.packetsFn);\n      } else {\n        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n      }\n      this.packetsFn = [];\n      this.transport.send(wbuf);\n      this.emit(\"drain\");\n      this.server.emit(\"drain\", this);\n    }\n  }\n  /**\n   * Get available upgrades for this socket.\n   *\n   * @api private\n   */\n  getAvailableUpgrades() {\n    const availableUpgrades = [];\n    const allUpgrades = this.server.upgrades(this.transport.name);\n    let i = 0;\n    const l = allUpgrades.length;\n    for (; i < l; ++i) {\n      const upg = allUpgrades[i];\n      if (this.server.opts.transports.indexOf(upg) !== -1) {\n        availableUpgrades.push(upg);\n      }\n    }\n    return availableUpgrades;\n  }\n  /**\n   * Closes the socket and underlying transport.\n   *\n   * @param {Boolean} discard - optional, discard the transport\n   * @return {Socket} for chaining\n   * @api public\n   */\n  close(discard) {\n    if (\"open\" !== this.readyState) return;\n    this.readyState = \"closing\";\n    if (this.writeBuffer.length) {\n      debug(\"there are %d remaining packets in the buffer, waiting for the 'drain' event\", this.writeBuffer.length);\n      this.once(\"drain\", () => {\n        debug(\"all packets have been sent, closing the transport\");\n        this.closeTransport(discard);\n      });\n      return;\n    }\n    debug(\"the buffer is empty, closing the transport right away\", discard);\n    this.closeTransport(discard);\n  }\n  /**\n   * Closes the underlying transport.\n   *\n   * @param {Boolean} discard\n   * @api private\n   */\n  closeTransport(discard) {\n    debug(\"closing the transport (discard? %s)\", discard);\n    if (discard) this.transport.discard();\n    this.transport.close(this.onClose.bind(this, \"forced close\"));\n  }\n}\nexports.Socket = Socket;","map":{"version":3,"names":["Object","defineProperty","exports","value","Socket","events_1","require","debug_1","timers_1","debug","default","EventEmitter","constructor","id","server","transport","req","protocol","_readyState","upgrading","upgraded","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","websocket","_socket","remoteAddress","connection","pingTimeoutTimer","pingIntervalTimer","setTransport","onOpen","readyState","state","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","opts","pingTimeout","maxPayload","maxHttpBufferSize","initialPacket","emit","resetPingTimeout","schedulePing","onPacket","packet","type","onError","refresh","onClose","data","err","setTimeout","timeout","clearTimeout","bind","flush","once","on","setupSendCallback","push","removeListener","maybeUpgrade","name","upgradeTimeoutTimer","cleanup","close","upgradeTimeout","checkIntervalTimer","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","options","callback","write","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/engine.io/build/socket.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"debug\");\nconst timers_1 = require(\"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    /**\n     * Client class (abstract).\n     *\n     * @api private\n     */\n    constructor(id, server, transport, req, protocol) {\n        super();\n        this._readyState = \"opening\";\n        this.upgrading = false;\n        this.upgraded = false;\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.id = id;\n        this.server = server;\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req) {\n            if (req.websocket && req.websocket._socket) {\n                this.remoteAddress = req.websocket._socket.remoteAddress;\n            }\n            else {\n                this.remoteAddress = req.connection.remoteAddress;\n            }\n        }\n        else {\n            // TODO there is currently no way to get the IP address of the client when it connects with WebTransport\n            //  see https://github.com/fails-components/webtransport/issues/114\n        }\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @api private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize,\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n        }\n        else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        // Reset ping timeout on any packet, incoming data is a good sign of\n        // other side's liveness\n        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n        switch (packet.type) {\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(\"invalid heartbeat direction\");\n                    return;\n                }\n                debug(\"got ping\");\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(\"invalid heartbeat direction\");\n                    return;\n                }\n                debug(\"got pong\");\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} err - error object\n     * @api private\n     */\n    onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @api private\n     */\n    schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout(this.server.opts.pingTimeout);\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @api private\n     */\n    resetPingTimeout(timeout) {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            if (this.readyState === \"closed\")\n                return;\n            this.onClose(\"ping timeout\");\n        }, timeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n    setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onPacket = this.onPacket.bind(this);\n        const flush = this.flush.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", flush);\n        this.transport.once(\"close\", onClose);\n        // this function will manage packet events (also message callbacks)\n        this.setupSendCallback();\n        this.cleanupFn.push(function () {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", flush);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n    maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        let checkIntervalTimer;\n        const onPacket = (packet) => {\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([{ type: \"pong\", data: \"probe\" }]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(checkIntervalTimer);\n                checkIntervalTimer = setInterval(check, 100);\n            }\n            else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(() => {\n                        this.onClose(\"forced close\");\n                    });\n                }\n            }\n            else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = () => {\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([{ type: \"noop\" }]);\n            }\n        };\n        const cleanup = () => {\n            this.upgrading = false;\n            clearInterval(checkIntervalTimer);\n            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = (err) => {\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = () => {\n            onError(\"transport closed\");\n        };\n        const onClose = () => {\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @api private\n     */\n    clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for (let i = 0; i < toCleanUp; i++) {\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function () {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */\n    onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(() => {\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Setup and manage send callback\n     *\n     * @api private\n     */\n    setupSendCallback() {\n        // the message was sent successfully, execute the callback\n        const onDrain = () => {\n            if (this.sentCallbackFn.length > 0) {\n                const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n                if (\"function\" === typeof seqFn) {\n                    debug(\"executing send callback\");\n                    seqFn(this.transport);\n                }\n                else if (Array.isArray(seqFn)) {\n                    debug(\"executing batch send callback\");\n                    const l = seqFn.length;\n                    let i = 0;\n                    for (; i < l; i++) {\n                        if (\"function\" === typeof seqFn[i]) {\n                            seqFn[i](this.transport);\n                        }\n                    }\n                }\n            }\n        };\n        this.transport.on(\"drain\", onDrain);\n        this.cleanupFn.push(() => {\n            this.transport.removeListener(\"drain\", onDrain);\n        });\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     * @api public\n     */\n    send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Alias of {@link send}.\n     *\n     * @param data\n     * @param options\n     * @param callback\n     */\n    write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @api private\n     */\n    sendPacket(type, data, options = {}, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = {};\n        }\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            // compression is enabled by default\n            options.compress = options.compress !== false;\n            const packet = {\n                type,\n                options: options,\n            };\n            if (data)\n                packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (callback)\n                this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (!this.transport.supportsFraming) {\n                this.sentCallbackFn.push(this.packetsFn);\n            }\n            else {\n                this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n            }\n            this.packetsFn = [];\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @api private\n     */\n    getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        let i = 0;\n        const l = allUpgrades.length;\n        for (; i < l; ++i) {\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     * @api public\n     */\n    close(discard) {\n        if (\"open\" !== this.readyState)\n            return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            debug(\"there are %d remaining packets in the buffer, waiting for the 'drain' event\", this.writeBuffer.length);\n            this.once(\"drain\", () => {\n                debug(\"all packets have been sent, closing the transport\");\n                this.closeTransport(discard);\n            });\n            return;\n        }\n        debug(\"the buffer is empty, closing the transport right away\", discard);\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @api private\n     */\n    closeTransport(discard) {\n        debug(\"closing the transport (discard? %s)\", discard);\n        if (discard)\n            this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}