{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = require(\"events\");\nconst yeast_1 = require(\"./contrib/yeast\");\nconst WebSocket = require(\"ws\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n  /**\n   * In-memory adapter constructor.\n   *\n   * @param {Namespace} nsp\n   */\n  constructor(nsp) {\n    super();\n    this.nsp = nsp;\n    this.rooms = new Map();\n    this.sids = new Map();\n    this.encoder = nsp.server.encoder;\n  }\n  /**\n   * To be overridden\n   */\n  init() {}\n  /**\n   * To be overridden\n   */\n  close() {}\n  /**\n   * Returns the number of Socket.IO servers in the cluster\n   *\n   * @public\n   */\n  serverCount() {\n    return Promise.resolve(1);\n  }\n  /**\n   * Adds a socket to a list of room.\n   *\n   * @param {SocketId}  id      the socket id\n   * @param {Set<Room>} rooms   a set of rooms\n   * @public\n   */\n  addAll(id, rooms) {\n    if (!this.sids.has(id)) {\n      this.sids.set(id, new Set());\n    }\n    for (const room of rooms) {\n      this.sids.get(id).add(room);\n      if (!this.rooms.has(room)) {\n        this.rooms.set(room, new Set());\n        this.emit(\"create-room\", room);\n      }\n      if (!this.rooms.get(room).has(id)) {\n        this.rooms.get(room).add(id);\n        this.emit(\"join-room\", room, id);\n      }\n    }\n  }\n  /**\n   * Removes a socket from a room.\n   *\n   * @param {SocketId} id     the socket id\n   * @param {Room}     room   the room name\n   */\n  del(id, room) {\n    if (this.sids.has(id)) {\n      this.sids.get(id).delete(room);\n    }\n    this._del(room, id);\n  }\n  _del(room, id) {\n    const _room = this.rooms.get(room);\n    if (_room != null) {\n      const deleted = _room.delete(id);\n      if (deleted) {\n        this.emit(\"leave-room\", room, id);\n      }\n      if (_room.size === 0 && this.rooms.delete(room)) {\n        this.emit(\"delete-room\", room);\n      }\n    }\n  }\n  /**\n   * Removes a socket from all rooms it's joined.\n   *\n   * @param {SocketId} id   the socket id\n   */\n  delAll(id) {\n    if (!this.sids.has(id)) {\n      return;\n    }\n    for (const room of this.sids.get(id)) {\n      this._del(room, id);\n    }\n    this.sids.delete(id);\n  }\n  /**\n   * Broadcasts a packet.\n   *\n   * Options:\n   *  - `flags` {Object} flags for this packet\n   *  - `except` {Array} sids that should be excluded\n   *  - `rooms` {Array} list of rooms to broadcast to\n   *\n   * @param {Object} packet   the packet object\n   * @param {Object} opts     the options\n   * @public\n   */\n  broadcast(packet, opts) {\n    const flags = opts.flags || {};\n    const packetOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name;\n    const encodedPackets = this._encode(packet, packetOpts);\n    this.apply(opts, socket => {\n      if (typeof socket.notifyOutgoingListeners === \"function\") {\n        socket.notifyOutgoingListeners(packet);\n      }\n      socket.client.writeToEngine(encodedPackets, packetOpts);\n    });\n  }\n  /**\n   * Broadcasts a packet and expects multiple acknowledgements.\n   *\n   * Options:\n   *  - `flags` {Object} flags for this packet\n   *  - `except` {Array} sids that should be excluded\n   *  - `rooms` {Array} list of rooms to broadcast to\n   *\n   * @param {Object} packet   the packet object\n   * @param {Object} opts     the options\n   * @param clientCountCallback - the number of clients that received the packet\n   * @param ack                 - the callback that will be called for each client response\n   *\n   * @public\n   */\n  broadcastWithAck(packet, opts, clientCountCallback, ack) {\n    const flags = opts.flags || {};\n    const packetOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name;\n    // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n    packet.id = this.nsp._ids++;\n    const encodedPackets = this._encode(packet, packetOpts);\n    let clientCount = 0;\n    this.apply(opts, socket => {\n      // track the total number of acknowledgements that are expected\n      clientCount++;\n      // call the ack callback for each client response\n      socket.acks.set(packet.id, ack);\n      if (typeof socket.notifyOutgoingListeners === \"function\") {\n        socket.notifyOutgoingListeners(packet);\n      }\n      socket.client.writeToEngine(encodedPackets, packetOpts);\n    });\n    clientCountCallback(clientCount);\n  }\n  _encode(packet, packetOpts) {\n    const encodedPackets = this.encoder.encode(packet);\n    if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === \"string\") {\n      // \"4\" being the \"message\" packet type in the Engine.IO protocol\n      const data = Buffer.from(\"4\" + encodedPackets[0]);\n      // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n      packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n        readOnly: false,\n        mask: false,\n        rsv1: false,\n        opcode: 1,\n        fin: true\n      });\n    }\n    return encodedPackets;\n  }\n  /**\n   * Gets a list of sockets by sid.\n   *\n   * @param {Set<Room>} rooms   the explicit set of rooms to check.\n   */\n  sockets(rooms) {\n    const sids = new Set();\n    this.apply({\n      rooms\n    }, socket => {\n      sids.add(socket.id);\n    });\n    return Promise.resolve(sids);\n  }\n  /**\n   * Gets the list of rooms a given socket has joined.\n   *\n   * @param {SocketId} id   the socket id\n   */\n  socketRooms(id) {\n    return this.sids.get(id);\n  }\n  /**\n   * Returns the matching socket instances\n   *\n   * @param opts - the filters to apply\n   */\n  fetchSockets(opts) {\n    const sockets = [];\n    this.apply(opts, socket => {\n      sockets.push(socket);\n    });\n    return Promise.resolve(sockets);\n  }\n  /**\n   * Makes the matching socket instances join the specified rooms\n   *\n   * @param opts - the filters to apply\n   * @param rooms - the rooms to join\n   */\n  addSockets(opts, rooms) {\n    this.apply(opts, socket => {\n      socket.join(rooms);\n    });\n  }\n  /**\n   * Makes the matching socket instances leave the specified rooms\n   *\n   * @param opts - the filters to apply\n   * @param rooms - the rooms to leave\n   */\n  delSockets(opts, rooms) {\n    this.apply(opts, socket => {\n      rooms.forEach(room => socket.leave(room));\n    });\n  }\n  /**\n   * Makes the matching socket instances disconnect\n   *\n   * @param opts - the filters to apply\n   * @param close - whether to close the underlying connection\n   */\n  disconnectSockets(opts, close) {\n    this.apply(opts, socket => {\n      socket.disconnect(close);\n    });\n  }\n  apply(opts, callback) {\n    const rooms = opts.rooms;\n    const except = this.computeExceptSids(opts.except);\n    if (rooms.size) {\n      const ids = new Set();\n      for (const room of rooms) {\n        if (!this.rooms.has(room)) continue;\n        for (const id of this.rooms.get(room)) {\n          if (ids.has(id) || except.has(id)) continue;\n          const socket = this.nsp.sockets.get(id);\n          if (socket) {\n            callback(socket);\n            ids.add(id);\n          }\n        }\n      }\n    } else {\n      for (const [id] of this.sids) {\n        if (except.has(id)) continue;\n        const socket = this.nsp.sockets.get(id);\n        if (socket) callback(socket);\n      }\n    }\n  }\n  computeExceptSids(exceptRooms) {\n    const exceptSids = new Set();\n    if (exceptRooms && exceptRooms.size > 0) {\n      for (const room of exceptRooms) {\n        if (this.rooms.has(room)) {\n          this.rooms.get(room).forEach(sid => exceptSids.add(sid));\n        }\n      }\n    }\n    return exceptSids;\n  }\n  /**\n   * Send a packet to the other Socket.IO servers in the cluster\n   * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n   */\n  serverSideEmit(packet) {\n    console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n  }\n  /**\n   * Save the client session in order to restore it upon reconnection.\n   */\n  persistSession(session) {}\n  /**\n   * Restore the session and find the packets that were missed by the client.\n   * @param pid\n   * @param offset\n   */\n  restoreSession(pid, offset) {\n    return null;\n  }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n  constructor(nsp) {\n    super(nsp);\n    this.nsp = nsp;\n    this.sessions = new Map();\n    this.packets = [];\n    this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n    const timer = setInterval(() => {\n      const threshold = Date.now() - this.maxDisconnectionDuration;\n      this.sessions.forEach((session, sessionId) => {\n        const hasExpired = session.disconnectedAt < threshold;\n        if (hasExpired) {\n          this.sessions.delete(sessionId);\n        }\n      });\n      for (let i = this.packets.length - 1; i >= 0; i--) {\n        const hasExpired = this.packets[i].emittedAt < threshold;\n        if (hasExpired) {\n          this.packets.splice(0, i + 1);\n          break;\n        }\n      }\n    }, 60 * 1000);\n    // prevents the timer from keeping the process alive\n    timer.unref();\n  }\n  persistSession(session) {\n    session.disconnectedAt = Date.now();\n    this.sessions.set(session.pid, session);\n  }\n  restoreSession(pid, offset) {\n    const session = this.sessions.get(pid);\n    if (!session) {\n      // the session may have expired\n      return null;\n    }\n    const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n    if (hasExpired) {\n      // the session has expired\n      this.sessions.delete(pid);\n      return null;\n    }\n    const index = this.packets.findIndex(packet => packet.id === offset);\n    if (index === -1) {\n      // the offset may be too old\n      return null;\n    }\n    const missedPackets = [];\n    for (let i = index + 1; i < this.packets.length; i++) {\n      const packet = this.packets[i];\n      if (shouldIncludePacket(session.rooms, packet.opts)) {\n        missedPackets.push(packet.data);\n      }\n    }\n    return Promise.resolve(Object.assign(Object.assign({}, session), {\n      missedPackets\n    }));\n  }\n  broadcast(packet, opts) {\n    var _a;\n    const isEventPacket = packet.type === 2;\n    // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n    // restored on another server upon reconnection\n    const withoutAcknowledgement = packet.id === undefined;\n    const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n    if (isEventPacket && withoutAcknowledgement && notVolatile) {\n      const id = (0, yeast_1.yeast)();\n      // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n      // processed (and the format is backward-compatible)\n      packet.data.push(id);\n      this.packets.push({\n        id,\n        opts,\n        data: packet.data,\n        emittedAt: Date.now()\n      });\n    }\n    super.broadcast(packet, opts);\n  }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n  const included = opts.rooms.size === 0 || sessionRooms.some(room => opts.rooms.has(room));\n  const notExcluded = sessionRooms.every(room => !opts.except.has(room));\n  return included && notExcluded;\n}","map":{"version":3,"names":["_a","Object","defineProperty","exports","value","SessionAwareAdapter","Adapter","events_1","require","yeast_1","WebSocket","canPreComputeFrame","Sender","frame","EventEmitter","constructor","nsp","rooms","Map","sids","encoder","server","init","close","serverCount","Promise","resolve","addAll","id","has","set","Set","room","get","add","emit","del","delete","_del","_room","deleted","size","delAll","broadcast","packet","opts","flags","packetOpts","preEncoded","volatile","compress","name","encodedPackets","_encode","apply","socket","notifyOutgoingListeners","client","writeToEngine","broadcastWithAck","clientCountCallback","ack","_ids","clientCount","acks","encode","length","data","Buffer","from","wsPreEncodedFrame","readOnly","mask","rsv1","opcode","fin","sockets","socketRooms","fetchSockets","push","addSockets","join","delSockets","forEach","leave","disconnectSockets","disconnect","callback","except","computeExceptSids","ids","exceptRooms","exceptSids","sid","serverSideEmit","console","warn","persistSession","session","restoreSession","pid","offset","sessions","packets","maxDisconnectionDuration","connectionStateRecovery","timer","setInterval","threshold","Date","now","sessionId","hasExpired","disconnectedAt","i","emittedAt","splice","unref","index","findIndex","missedPackets","shouldIncludePacket","assign","isEventPacket","type","withoutAcknowledgement","undefined","notVolatile","yeast","sessionRooms","included","some","notExcluded","every"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/socket.io-adapter/dist/index.js"],"sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = require(\"events\");\nconst yeast_1 = require(\"./contrib/yeast\");\nconst WebSocket = require(\"ws\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */\n    constructor(nsp) {\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */\n    init() { }\n    /**\n     * To be overridden\n     */\n    close() { }\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */\n    serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */\n    addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms) {\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */\n    del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)) {\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */\n    broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket) => {\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket) => {\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame &&\n            encodedPackets.length === 1 &&\n            typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true,\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */\n    sockets(rooms) {\n        const sids = new Set();\n        this.apply({ rooms }, (socket) => {\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */\n    fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket) => {\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */\n    addSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */\n    delSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            rooms.forEach((room) => socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(opts, close) {\n        this.apply(opts, (socket) => {\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms) {\n                if (!this.rooms.has(room))\n                    continue;\n                for (const id of this.rooms.get(room)) {\n                    if (ids.has(id) || except.has(id))\n                        continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        }\n        else {\n            for (const [id] of this.sids) {\n                if (except.has(id))\n                    continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket)\n                    callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms) {\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid) => exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */\n    persistSession(session) { }\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */\n    restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration =\n            nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(() => {\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId) => {\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for (let i = this.packets.length - 1; i >= 0; i--) {\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet) => packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for (let i = index + 1; i < this.packets.length; i++) {\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now(),\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));\n    return included && notExcluded;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}