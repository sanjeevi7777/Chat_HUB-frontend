{"ast":null,"code":"'use strict';\n\nconst {\n  Writable\n} = require('stream');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = require('./buffer-util');\nconst {\n  isValidStatusCode,\n  isValidUTF8\n} = require('./validation');\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n    }\n    const compressed = (buf[0] & 0x40) === 0x40;\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n    }\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      }\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n      }\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      }\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n    }\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      }\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 0x07) return this.controlMessage(data);\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));\n        }\n        this._fragments.push(buf);\n      }\n      const er = this.dataMessage();\n      if (er) return cb(er);\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        let data;\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        }\n        this.emit('message', buf, false);\n      }\n    }\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n        }\n        const buf = data.slice(2);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        }\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n    this._state = GET_INFO;\n  }\n}\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}","map":{"version":3,"names":["Writable","require","PerMessageDeflate","BINARY_TYPES","EMPTY_BUFFER","kStatusCode","kWebSocket","concat","toArrayBuffer","unmask","isValidStatusCode","isValidUTF8","GET_INFO","GET_PAYLOAD_LENGTH_16","GET_PAYLOAD_LENGTH_64","GET_MASK","GET_DATA","INFLATING","Receiver","constructor","options","_binaryType","binaryType","_extensions","extensions","_isServer","isServer","_maxPayload","maxPayload","_skipUTF8Validation","skipUTF8Validation","undefined","_bufferedBytes","_buffers","_compressed","_payloadLength","_mask","_fragmented","_masked","_fin","_opcode","_totalPayloadLength","_messageLength","_fragments","_state","_loop","_write","chunk","encoding","cb","length","push","startLoop","consume","n","shift","buf","slice","dst","Buffer","allocUnsafe","offset","set","Uint8Array","buffer","byteOffset","err","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","error","RangeError","compressed","extensionName","haveLength","readUInt16BE","num","readUInt32BE","Math","pow","data","controlMessage","decompress","dataMessage","perMessageDeflate","er","messageLength","fragments","emit","Error","end","code","module","exports","ErrorCtor","message","prefix","statusCode","errorCode","captureStackTrace"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/socket.io-adapter/node_modules/ws/lib/receiver.js"],"sourcesContent":["'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              'Max payload size exceeded',\n              false,\n              1009,\n              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n            )\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('message', buf, false);\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else if (data.length === 1) {\n        return error(\n          RangeError,\n          'invalid payload length 1',\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n        }\n\n        const buf = data.slice(2);\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n        }\n\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}