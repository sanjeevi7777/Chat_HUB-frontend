{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n  constructor(server) {\n    super(server, \"/_\" + ParentNamespace.count++);\n    this.children = new Set();\n  }\n  /**\n   * @private\n   */\n  _initAdapter() {\n    const broadcast = (packet, opts) => {\n      this.children.forEach(nsp => {\n        nsp.adapter.broadcast(packet, opts);\n      });\n    };\n    // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n    this.adapter = {\n      broadcast\n    };\n  }\n  emit(ev, ...args) {\n    this.children.forEach(nsp => {\n      nsp.emit(ev, ...args);\n    });\n    return true;\n  }\n  createChild(name) {\n    debug(\"creating child namespace %s\", name);\n    const namespace = new namespace_1.Namespace(this.server, name);\n    namespace._fns = this._fns.slice(0);\n    this.listeners(\"connect\").forEach(listener => namespace.on(\"connect\", listener));\n    this.listeners(\"connection\").forEach(listener => namespace.on(\"connection\", listener));\n    this.children.add(namespace);\n    if (this.server._opts.cleanupEmptyChildNamespaces) {\n      const remove = namespace._remove;\n      namespace._remove = socket => {\n        remove.call(namespace, socket);\n        if (namespace.sockets.size === 0) {\n          debug(\"closing child namespace %s\", name);\n          namespace.adapter.close();\n          this.server._nsps.delete(namespace.name);\n          this.children.delete(namespace);\n        }\n      };\n    }\n    this.server._nsps.set(name, namespace);\n    // @ts-ignore\n    this.server.sockets.emitReserved(\"new_namespace\", namespace);\n    return namespace;\n  }\n  fetchSockets() {\n    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n    // the behavior for namespaces created with a function is less clear\n    // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n    // may exist on one node but not exist on another (since it is created upon client connection)\n    throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n  }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","debug_1","debug","default","Namespace","constructor","server","count","children","Set","_initAdapter","broadcast","packet","opts","forEach","nsp","adapter","emit","ev","args","createChild","name","namespace","_fns","slice","listeners","listener","on","add","_opts","cleanupEmptyChildNamespaces","remove","_remove","socket","call","sockets","size","close","_nsps","delete","set","emitReserved","fetchSockets","Error"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/socket.io/dist/parent-namespace.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        const broadcast = (packet, opts) => {\n            this.children.forEach((nsp) => {\n                nsp.adapter.broadcast(packet, opts);\n            });\n        };\n        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n        this.adapter = { broadcast };\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        namespace._fns = this._fns.slice(0);\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket) => {\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}