{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst {\n  randomFillSync\n} = require('crypto');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\nconst {\n  isValidStatusCode\n} = require('./validation');\nconst {\n  mask: applyMask,\n  toBuffer\n} = require('./buffer-util');\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n    let dataLength;\n    if (typeof data === 'string') {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n    let payloadLength = dataLength;\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    target[1] = payloadLength;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n    if (!options.mask) return [target, data];\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n    if (skipMasking) return [target, data];\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin) this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1: false\n      }), cb);\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error('The socket was closed while data was being compressed');\n        if (typeof cb === 'function') cb(err);\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === 'function') callback(err);\n        }\n        return;\n      }\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\nmodule.exports = Sender;","map":{"version":3,"names":["net","require","tls","randomFillSync","PerMessageDeflate","EMPTY_BUFFER","isValidStatusCode","mask","applyMask","toBuffer","kByteLength","Symbol","maskBuffer","Buffer","alloc","Sender","constructor","socket","extensions","generateMask","_extensions","_generateMask","_maskBuffer","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","frame","data","options","merge","offset","skipMasking","dataLength","undefined","from","length","readOnly","payloadLength","target","allocUnsafe","fin","opcode","rsv1","writeUInt16BE","writeUIntBE","close","code","cb","buf","TypeError","byteLength","RangeError","write","set","enqueue","dispatch","sendFrame","ping","pong","send","perMessageDeflate","extensionName","binary","compress","params","_isServer","_threshold","opts","_","destroyed","err","Error","i","callback","dequeue","shift","Reflect","apply","slice","push","list","cork","uncork","module","exports"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/socket.io-adapter/node_modules/ws/lib/sender.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}