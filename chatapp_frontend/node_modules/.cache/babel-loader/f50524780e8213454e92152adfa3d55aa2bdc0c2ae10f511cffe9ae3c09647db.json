{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst https = require('https');\nconst net = require('net');\nconst tls = require('tls');\nconst {\n  createHash\n} = require('crypto');\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst {\n  GUID,\n  kWebSocket\n} = require('./constants');\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb) this.once('close', cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const key = req.headers['sec-websocket-key'];\n    const version = +req.headers['sec-websocket-version'];\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!key || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n    }\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new this.options.WebSocket(null);\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once('finish', socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}","map":{"version":3,"names":["EventEmitter","require","http","https","net","tls","createHash","extension","PerMessageDeflate","subprotocol","WebSocket","GUID","kWebSocket","keyRegex","RUNNING","CLOSING","CLOSED","WebSocketServer","constructor","options","callback","maxPayload","skipUTF8Validation","perMessageDeflate","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","TypeError","_server","createServer","req","res","body","STATUS_CODES","writeHead","length","end","listen","emitConnection","emit","bind","_removeListeners","addListeners","listening","error","upgrade","socket","head","handleUpgrade","clients","Set","_shouldEmitClose","_state","address","Error","close","cb","once","process","nextTick","emitClose","size","shouldHandle","index","url","indexOf","pathname","slice","on","socketOnError","key","headers","version","method","message","abortHandshakeOrEmitwsClientError","toLowerCase","test","abortHandshake","secWebSocketProtocol","protocols","undefined","parse","err","secWebSocketExtensions","extensions","offers","extensionName","accept","info","origin","secure","authorized","encrypted","verified","code","completeUpgrade","readable","writable","destroy","digest","update","ws","protocol","values","next","value","push","_protocol","params","format","_extensions","write","concat","join","removeListener","setSocket","add","delete","module","exports","map","event","Object","keys","removeListeners","Connection","Buffer","byteLength","h","listenerCount","captureStackTrace"],"sources":["C:/Users/sanjeevi/Desktop/chatapp/chatapp_frontend/node_modules/engine.io/node_modules/ws/lib/websocket-server.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst https = require('https');\nconst net = require('net');\nconst tls = require('tls');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!key || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n"],"mappings":"AAAA;;AAEA,YAAY;;AAEZ,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAMG,GAAG,GAAGH,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMI,GAAG,GAAGJ,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAM;EAAEK;AAAW,CAAC,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAExC,MAAMM,SAAS,GAAGN,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMO,iBAAiB,GAAGP,OAAO,CAAC,sBAAsB,CAAC;AACzD,MAAMQ,WAAW,GAAGR,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAMS,SAAS,GAAGT,OAAO,CAAC,aAAa,CAAC;AACxC,MAAM;EAAEU,IAAI;EAAEC;AAAW,CAAC,GAAGX,OAAO,CAAC,aAAa,CAAC;AAEnD,MAAMY,QAAQ,GAAG,uBAAuB;AAExC,MAAMC,OAAO,GAAG,CAAC;AACjB,MAAMC,OAAO,GAAG,CAAC;AACjB,MAAMC,MAAM,GAAG,CAAC;;AAEhB;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,SAASjB,YAAY,CAAC;EACzC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkB,WAAWA,CAACC,OAAO,EAAEC,QAAQ,EAAE;IAC7B,KAAK,CAAC,CAAC;IAEPD,OAAO,GAAG;MACRE,UAAU,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI;MAC7BC,kBAAkB,EAAE,KAAK;MACzBC,iBAAiB,EAAE,KAAK;MACxBC,eAAe,EAAE,IAAI;MACrBC,cAAc,EAAE,IAAI;MACpBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,KAAK;MACfC,OAAO,EAAE,IAAI;MAAE;MACfC,MAAM,EAAE,IAAI;MACZC,IAAI,EAAE,IAAI;MACVC,IAAI,EAAE,IAAI;MACVC,IAAI,EAAE,IAAI;MACVtB,SAAS;MACT,GAAGS;IACL,CAAC;IAED,IACGA,OAAO,CAACa,IAAI,IAAI,IAAI,IAAI,CAACb,OAAO,CAACU,MAAM,IAAI,CAACV,OAAO,CAACQ,QAAQ,IAC5DR,OAAO,CAACa,IAAI,IAAI,IAAI,KAAKb,OAAO,CAACU,MAAM,IAAIV,OAAO,CAACQ,QAAQ,CAAE,IAC7DR,OAAO,CAACU,MAAM,IAAIV,OAAO,CAACQ,QAAS,EACpC;MACA,MAAM,IAAIM,SAAS,CACjB,kEAAkE,GAChE,mBACJ,CAAC;IACH;IAEA,IAAId,OAAO,CAACa,IAAI,IAAI,IAAI,EAAE;MACxB,IAAI,CAACE,OAAO,GAAGhC,IAAI,CAACiC,YAAY,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;QAC7C,MAAMC,IAAI,GAAGpC,IAAI,CAACqC,YAAY,CAAC,GAAG,CAAC;QAEnCF,GAAG,CAACG,SAAS,CAAC,GAAG,EAAE;UACjB,gBAAgB,EAAEF,IAAI,CAACG,MAAM;UAC7B,cAAc,EAAE;QAClB,CAAC,CAAC;QACFJ,GAAG,CAACK,GAAG,CAACJ,IAAI,CAAC;MACf,CAAC,CAAC;MACF,IAAI,CAACJ,OAAO,CAACS,MAAM,CACjBxB,OAAO,CAACa,IAAI,EACZb,OAAO,CAACW,IAAI,EACZX,OAAO,CAACS,OAAO,EACfR,QACF,CAAC;IACH,CAAC,MAAM,IAAID,OAAO,CAACU,MAAM,EAAE;MACzB,IAAI,CAACK,OAAO,GAAGf,OAAO,CAACU,MAAM;IAC/B;IAEA,IAAI,IAAI,CAACK,OAAO,EAAE;MAChB,MAAMU,cAAc,GAAG,IAAI,CAACC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC;MAEzD,IAAI,CAACC,gBAAgB,GAAGC,YAAY,CAAC,IAAI,CAACd,OAAO,EAAE;QACjDe,SAAS,EAAE,IAAI,CAACJ,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE,WAAW,CAAC;QAC5CI,KAAK,EAAE,IAAI,CAACL,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC;QACpCK,OAAO,EAAEA,CAACf,GAAG,EAAEgB,MAAM,EAAEC,IAAI,KAAK;UAC9B,IAAI,CAACC,aAAa,CAAClB,GAAG,EAAEgB,MAAM,EAAEC,IAAI,EAAET,cAAc,CAAC;QACvD;MACF,CAAC,CAAC;IACJ;IAEA,IAAIzB,OAAO,CAACI,iBAAiB,KAAK,IAAI,EAAEJ,OAAO,CAACI,iBAAiB,GAAG,CAAC,CAAC;IACtE,IAAIJ,OAAO,CAACM,cAAc,EAAE;MAC1B,IAAI,CAAC8B,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;MACxB,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC/B;IAEA,IAAI,CAACtC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACuC,MAAM,GAAG5C,OAAO;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6C,OAAOA,CAAA,EAAG;IACR,IAAI,IAAI,CAACxC,OAAO,CAACQ,QAAQ,EAAE;MACzB,MAAM,IAAIiC,KAAK,CAAC,4CAA4C,CAAC;IAC/D;IAEA,IAAI,CAAC,IAAI,CAAC1B,OAAO,EAAE,OAAO,IAAI;IAC9B,OAAO,IAAI,CAACA,OAAO,CAACyB,OAAO,CAAC,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,KAAKA,CAACC,EAAE,EAAE;IACR,IAAI,IAAI,CAACJ,MAAM,KAAK1C,MAAM,EAAE;MAC1B,IAAI8C,EAAE,EAAE;QACN,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE,MAAM;UACvBD,EAAE,CAAC,IAAIF,KAAK,CAAC,2BAA2B,CAAC,CAAC;QAC5C,CAAC,CAAC;MACJ;MAEAI,OAAO,CAACC,QAAQ,CAACC,SAAS,EAAE,IAAI,CAAC;MACjC;IACF;IAEA,IAAIJ,EAAE,EAAE,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,EAAE,CAAC;IAE9B,IAAI,IAAI,CAACJ,MAAM,KAAK3C,OAAO,EAAE;IAC7B,IAAI,CAAC2C,MAAM,GAAG3C,OAAO;IAErB,IAAI,IAAI,CAACI,OAAO,CAACQ,QAAQ,IAAI,IAAI,CAACR,OAAO,CAACU,MAAM,EAAE;MAChD,IAAI,IAAI,CAACK,OAAO,EAAE;QAChB,IAAI,CAACa,gBAAgB,CAAC,CAAC;QACvB,IAAI,CAACA,gBAAgB,GAAG,IAAI,CAACb,OAAO,GAAG,IAAI;MAC7C;MAEA,IAAI,IAAI,CAACqB,OAAO,EAAE;QAChB,IAAI,CAAC,IAAI,CAACA,OAAO,CAACY,IAAI,EAAE;UACtBH,OAAO,CAACC,QAAQ,CAACC,SAAS,EAAE,IAAI,CAAC;QACnC,CAAC,MAAM;UACL,IAAI,CAACT,gBAAgB,GAAG,IAAI;QAC9B;MACF,CAAC,MAAM;QACLO,OAAO,CAACC,QAAQ,CAACC,SAAS,EAAE,IAAI,CAAC;MACnC;IACF,CAAC,MAAM;MACL,MAAMrC,MAAM,GAAG,IAAI,CAACK,OAAO;MAE3B,IAAI,CAACa,gBAAgB,CAAC,CAAC;MACvB,IAAI,CAACA,gBAAgB,GAAG,IAAI,CAACb,OAAO,GAAG,IAAI;;MAE3C;MACA;MACA;MACA;MACAL,MAAM,CAACgC,KAAK,CAAC,MAAM;QACjBK,SAAS,CAAC,IAAI,CAAC;MACjB,CAAC,CAAC;IACJ;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,YAAYA,CAAChC,GAAG,EAAE;IAChB,IAAI,IAAI,CAACjB,OAAO,CAACY,IAAI,EAAE;MACrB,MAAMsC,KAAK,GAAGjC,GAAG,CAACkC,GAAG,CAACC,OAAO,CAAC,GAAG,CAAC;MAClC,MAAMC,QAAQ,GAAGH,KAAK,KAAK,CAAC,CAAC,GAAGjC,GAAG,CAACkC,GAAG,CAACG,KAAK,CAAC,CAAC,EAAEJ,KAAK,CAAC,GAAGjC,GAAG,CAACkC,GAAG;MAEjE,IAAIE,QAAQ,KAAK,IAAI,CAACrD,OAAO,CAACY,IAAI,EAAE,OAAO,KAAK;IAClD;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuB,aAAaA,CAAClB,GAAG,EAAEgB,MAAM,EAAEC,IAAI,EAAES,EAAE,EAAE;IACnCV,MAAM,CAACsB,EAAE,CAAC,OAAO,EAAEC,aAAa,CAAC;IAEjC,MAAMC,GAAG,GAAGxC,GAAG,CAACyC,OAAO,CAAC,mBAAmB,CAAC;IAC5C,MAAMC,OAAO,GAAG,CAAC1C,GAAG,CAACyC,OAAO,CAAC,uBAAuB,CAAC;IAErD,IAAIzC,GAAG,CAAC2C,MAAM,KAAK,KAAK,EAAE;MACxB,MAAMC,OAAO,GAAG,qBAAqB;MACrCC,iCAAiC,CAAC,IAAI,EAAE7C,GAAG,EAAEgB,MAAM,EAAE,GAAG,EAAE4B,OAAO,CAAC;MAClE;IACF;IAEA,IAAI5C,GAAG,CAACyC,OAAO,CAAC1B,OAAO,CAAC+B,WAAW,CAAC,CAAC,KAAK,WAAW,EAAE;MACrD,MAAMF,OAAO,GAAG,wBAAwB;MACxCC,iCAAiC,CAAC,IAAI,EAAE7C,GAAG,EAAEgB,MAAM,EAAE,GAAG,EAAE4B,OAAO,CAAC;MAClE;IACF;IAEA,IAAI,CAACJ,GAAG,IAAI,CAAC/D,QAAQ,CAACsE,IAAI,CAACP,GAAG,CAAC,EAAE;MAC/B,MAAMI,OAAO,GAAG,6CAA6C;MAC7DC,iCAAiC,CAAC,IAAI,EAAE7C,GAAG,EAAEgB,MAAM,EAAE,GAAG,EAAE4B,OAAO,CAAC;MAClE;IACF;IAEA,IAAIF,OAAO,KAAK,CAAC,IAAIA,OAAO,KAAK,EAAE,EAAE;MACnC,MAAME,OAAO,GAAG,iDAAiD;MACjEC,iCAAiC,CAAC,IAAI,EAAE7C,GAAG,EAAEgB,MAAM,EAAE,GAAG,EAAE4B,OAAO,CAAC;MAClE;IACF;IAEA,IAAI,CAAC,IAAI,CAACZ,YAAY,CAAChC,GAAG,CAAC,EAAE;MAC3BgD,cAAc,CAAChC,MAAM,EAAE,GAAG,CAAC;MAC3B;IACF;IAEA,MAAMiC,oBAAoB,GAAGjD,GAAG,CAACyC,OAAO,CAAC,wBAAwB,CAAC;IAClE,IAAIS,SAAS,GAAG,IAAI9B,GAAG,CAAC,CAAC;IAEzB,IAAI6B,oBAAoB,KAAKE,SAAS,EAAE;MACtC,IAAI;QACFD,SAAS,GAAG7E,WAAW,CAAC+E,KAAK,CAACH,oBAAoB,CAAC;MACrD,CAAC,CAAC,OAAOI,GAAG,EAAE;QACZ,MAAMT,OAAO,GAAG,uCAAuC;QACvDC,iCAAiC,CAAC,IAAI,EAAE7C,GAAG,EAAEgB,MAAM,EAAE,GAAG,EAAE4B,OAAO,CAAC;QAClE;MACF;IACF;IAEA,MAAMU,sBAAsB,GAAGtD,GAAG,CAACyC,OAAO,CAAC,0BAA0B,CAAC;IACtE,MAAMc,UAAU,GAAG,CAAC,CAAC;IAErB,IACE,IAAI,CAACxE,OAAO,CAACI,iBAAiB,IAC9BmE,sBAAsB,KAAKH,SAAS,EACpC;MACA,MAAMhE,iBAAiB,GAAG,IAAIf,iBAAiB,CAC7C,IAAI,CAACW,OAAO,CAACI,iBAAiB,EAC9B,IAAI,EACJ,IAAI,CAACJ,OAAO,CAACE,UACf,CAAC;MAED,IAAI;QACF,MAAMuE,MAAM,GAAGrF,SAAS,CAACiF,KAAK,CAACE,sBAAsB,CAAC;QAEtD,IAAIE,MAAM,CAACpF,iBAAiB,CAACqF,aAAa,CAAC,EAAE;UAC3CtE,iBAAiB,CAACuE,MAAM,CAACF,MAAM,CAACpF,iBAAiB,CAACqF,aAAa,CAAC,CAAC;UACjEF,UAAU,CAACnF,iBAAiB,CAACqF,aAAa,CAAC,GAAGtE,iBAAiB;QACjE;MACF,CAAC,CAAC,OAAOkE,GAAG,EAAE;QACZ,MAAMT,OAAO,GACX,yDAAyD;QAC3DC,iCAAiC,CAAC,IAAI,EAAE7C,GAAG,EAAEgB,MAAM,EAAE,GAAG,EAAE4B,OAAO,CAAC;QAClE;MACF;IACF;;IAEA;IACA;IACA;IACA,IAAI,IAAI,CAAC7D,OAAO,CAACO,YAAY,EAAE;MAC7B,MAAMqE,IAAI,GAAG;QACXC,MAAM,EACJ5D,GAAG,CAACyC,OAAO,CAAE,GAAEC,OAAO,KAAK,CAAC,GAAG,sBAAsB,GAAG,QAAS,EAAC,CAAC;QACrEmB,MAAM,EAAE,CAAC,EAAE7D,GAAG,CAACgB,MAAM,CAAC8C,UAAU,IAAI9D,GAAG,CAACgB,MAAM,CAAC+C,SAAS,CAAC;QACzD/D;MACF,CAAC;MAED,IAAI,IAAI,CAACjB,OAAO,CAACO,YAAY,CAACe,MAAM,KAAK,CAAC,EAAE;QAC1C,IAAI,CAACtB,OAAO,CAACO,YAAY,CAACqE,IAAI,EAAE,CAACK,QAAQ,EAAEC,IAAI,EAAErB,OAAO,EAAEH,OAAO,KAAK;UACpE,IAAI,CAACuB,QAAQ,EAAE;YACb,OAAOhB,cAAc,CAAChC,MAAM,EAAEiD,IAAI,IAAI,GAAG,EAAErB,OAAO,EAAEH,OAAO,CAAC;UAC9D;UAEA,IAAI,CAACyB,eAAe,CAClBX,UAAU,EACVf,GAAG,EACHU,SAAS,EACTlD,GAAG,EACHgB,MAAM,EACNC,IAAI,EACJS,EACF,CAAC;QACH,CAAC,CAAC;QACF;MACF;MAEA,IAAI,CAAC,IAAI,CAAC3C,OAAO,CAACO,YAAY,CAACqE,IAAI,CAAC,EAAE,OAAOX,cAAc,CAAChC,MAAM,EAAE,GAAG,CAAC;IAC1E;IAEA,IAAI,CAACkD,eAAe,CAACX,UAAU,EAAEf,GAAG,EAAEU,SAAS,EAAElD,GAAG,EAAEgB,MAAM,EAAEC,IAAI,EAAES,EAAE,CAAC;EACzE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwC,eAAeA,CAACX,UAAU,EAAEf,GAAG,EAAEU,SAAS,EAAElD,GAAG,EAAEgB,MAAM,EAAEC,IAAI,EAAES,EAAE,EAAE;IACjE;IACA;IACA;IACA,IAAI,CAACV,MAAM,CAACmD,QAAQ,IAAI,CAACnD,MAAM,CAACoD,QAAQ,EAAE,OAAOpD,MAAM,CAACqD,OAAO,CAAC,CAAC;IAEjE,IAAIrD,MAAM,CAACxC,UAAU,CAAC,EAAE;MACtB,MAAM,IAAIgD,KAAK,CACb,iEAAiE,GAC/D,4CACJ,CAAC;IACH;IAEA,IAAI,IAAI,CAACF,MAAM,GAAG5C,OAAO,EAAE,OAAOsE,cAAc,CAAChC,MAAM,EAAE,GAAG,CAAC;IAE7D,MAAMsD,MAAM,GAAGpG,UAAU,CAAC,MAAM,CAAC,CAC9BqG,MAAM,CAAC/B,GAAG,GAAGjE,IAAI,CAAC,CAClB+F,MAAM,CAAC,QAAQ,CAAC;IAEnB,MAAM7B,OAAO,GAAG,CACd,kCAAkC,EAClC,oBAAoB,EACpB,qBAAqB,EACpB,yBAAwB6B,MAAO,EAAC,CAClC;IAED,MAAME,EAAE,GAAG,IAAI,IAAI,CAACzF,OAAO,CAACT,SAAS,CAAC,IAAI,CAAC;IAE3C,IAAI4E,SAAS,CAACnB,IAAI,EAAE;MAClB;MACA;MACA;MACA,MAAM0C,QAAQ,GAAG,IAAI,CAAC1F,OAAO,CAACK,eAAe,GACzC,IAAI,CAACL,OAAO,CAACK,eAAe,CAAC8D,SAAS,EAAElD,GAAG,CAAC,GAC5CkD,SAAS,CAACwB,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAK;MAEnC,IAAIH,QAAQ,EAAE;QACZhC,OAAO,CAACoC,IAAI,CAAE,2BAA0BJ,QAAS,EAAC,CAAC;QACnDD,EAAE,CAACM,SAAS,GAAGL,QAAQ;MACzB;IACF;IAEA,IAAIlB,UAAU,CAACnF,iBAAiB,CAACqF,aAAa,CAAC,EAAE;MAC/C,MAAMsB,MAAM,GAAGxB,UAAU,CAACnF,iBAAiB,CAACqF,aAAa,CAAC,CAACsB,MAAM;MACjE,MAAMH,KAAK,GAAGzG,SAAS,CAAC6G,MAAM,CAAC;QAC7B,CAAC5G,iBAAiB,CAACqF,aAAa,GAAG,CAACsB,MAAM;MAC5C,CAAC,CAAC;MACFtC,OAAO,CAACoC,IAAI,CAAE,6BAA4BD,KAAM,EAAC,CAAC;MAClDJ,EAAE,CAACS,WAAW,GAAG1B,UAAU;IAC7B;;IAEA;IACA;IACA;IACA,IAAI,CAAC9C,IAAI,CAAC,SAAS,EAAEgC,OAAO,EAAEzC,GAAG,CAAC;IAElCgB,MAAM,CAACkE,KAAK,CAACzC,OAAO,CAAC0C,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,MAAM,CAAC,CAAC;IACjDpE,MAAM,CAACqE,cAAc,CAAC,OAAO,EAAE9C,aAAa,CAAC;IAE7CiC,EAAE,CAACc,SAAS,CAACtE,MAAM,EAAEC,IAAI,EAAE;MACzBhC,UAAU,EAAE,IAAI,CAACF,OAAO,CAACE,UAAU;MACnCC,kBAAkB,EAAE,IAAI,CAACH,OAAO,CAACG;IACnC,CAAC,CAAC;IAEF,IAAI,IAAI,CAACiC,OAAO,EAAE;MAChB,IAAI,CAACA,OAAO,CAACoE,GAAG,CAACf,EAAE,CAAC;MACpBA,EAAE,CAAClC,EAAE,CAAC,OAAO,EAAE,MAAM;QACnB,IAAI,CAACnB,OAAO,CAACqE,MAAM,CAAChB,EAAE,CAAC;QAEvB,IAAI,IAAI,CAACnD,gBAAgB,IAAI,CAAC,IAAI,CAACF,OAAO,CAACY,IAAI,EAAE;UAC/CH,OAAO,CAACC,QAAQ,CAACC,SAAS,EAAE,IAAI,CAAC;QACnC;MACF,CAAC,CAAC;IACJ;IAEAJ,EAAE,CAAC8C,EAAE,EAAExE,GAAG,CAAC;EACb;AACF;AAEAyF,MAAM,CAACC,OAAO,GAAG7G,eAAe;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+B,YAAYA,CAACnB,MAAM,EAAEkG,GAAG,EAAE;EACjC,KAAK,MAAMC,KAAK,IAAIC,MAAM,CAACC,IAAI,CAACH,GAAG,CAAC,EAAElG,MAAM,CAAC6C,EAAE,CAACsD,KAAK,EAAED,GAAG,CAACC,KAAK,CAAC,CAAC;EAElE,OAAO,SAASG,eAAeA,CAAA,EAAG;IAChC,KAAK,MAAMH,KAAK,IAAIC,MAAM,CAACC,IAAI,CAACH,GAAG,CAAC,EAAE;MACpClG,MAAM,CAAC4F,cAAc,CAACO,KAAK,EAAED,GAAG,CAACC,KAAK,CAAC,CAAC;IAC1C;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9D,SAASA,CAACrC,MAAM,EAAE;EACzBA,MAAM,CAAC6B,MAAM,GAAG1C,MAAM;EACtBa,MAAM,CAACgB,IAAI,CAAC,OAAO,CAAC;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS8B,aAAaA,CAAA,EAAG;EACvB,IAAI,CAAC8B,OAAO,CAAC,CAAC;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrB,cAAcA,CAAChC,MAAM,EAAEiD,IAAI,EAAErB,OAAO,EAAEH,OAAO,EAAE;EACtD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAG,OAAO,GAAGA,OAAO,IAAI9E,IAAI,CAACqC,YAAY,CAAC8D,IAAI,CAAC;EAC5CxB,OAAO,GAAG;IACRuD,UAAU,EAAE,OAAO;IACnB,cAAc,EAAE,WAAW;IAC3B,gBAAgB,EAAEC,MAAM,CAACC,UAAU,CAACtD,OAAO,CAAC;IAC5C,GAAGH;EACL,CAAC;EAEDzB,MAAM,CAACW,IAAI,CAAC,QAAQ,EAAEX,MAAM,CAACqD,OAAO,CAAC;EAErCrD,MAAM,CAACV,GAAG,CACP,YAAW2D,IAAK,IAAGnG,IAAI,CAACqC,YAAY,CAAC8D,IAAI,CAAE,MAAK,GAC/C4B,MAAM,CAACC,IAAI,CAACrD,OAAO,CAAC,CACjBkD,GAAG,CAAEQ,CAAC,IAAM,GAAEA,CAAE,KAAI1D,OAAO,CAAC0D,CAAC,CAAE,EAAC,CAAC,CACjCf,IAAI,CAAC,MAAM,CAAC,GACf,UAAU,GACVxC,OACJ,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iCAAiCA,CAACpD,MAAM,EAAEO,GAAG,EAAEgB,MAAM,EAAEiD,IAAI,EAAErB,OAAO,EAAE;EAC7E,IAAInD,MAAM,CAAC2G,aAAa,CAAC,eAAe,CAAC,EAAE;IACzC,MAAM/C,GAAG,GAAG,IAAI7B,KAAK,CAACoB,OAAO,CAAC;IAC9BpB,KAAK,CAAC6E,iBAAiB,CAAChD,GAAG,EAAER,iCAAiC,CAAC;IAE/DpD,MAAM,CAACgB,IAAI,CAAC,eAAe,EAAE4C,GAAG,EAAErC,MAAM,EAAEhB,GAAG,CAAC;EAChD,CAAC,MAAM;IACLgD,cAAc,CAAChC,MAAM,EAAEiD,IAAI,EAAErB,OAAO,CAAC;EACvC;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}